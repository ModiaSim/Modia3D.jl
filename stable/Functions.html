<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · Modia3D</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">Modia3D</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="tutorial/Tutorial.html">Modia3D Tutorial</a></li><li><a class="tocitem" href="tutorial/GettingStarted.html">Getting Started</a></li><li><a class="tocitem" href="tutorial/HierarchicalModels.html">Hierarchical models</a></li><li><a class="tocitem" href="tutorial/RecursiveModels.html">Recursive models</a></li><li><a class="tocitem" href="tutorial/CollisionHandling.html">Collision Handling</a></li><li><a class="tocitem" href="tutorial/SegmentedSimulation.html">Segmented Simulation</a></li></ul></li><li><span class="tocitem">Components</span><ul><li><a class="tocitem" href="Components/Object3D.html">Object3D</a></li><li><a class="tocitem" href="Components/Shapes.html">Shapes</a></li><li><a class="tocitem" href="Components/Joints.html">Joints</a></li><li><a class="tocitem" href="Components/Materials.html">Materials</a></li><li><a class="tocitem" href="Components/GravityField.html">Gravity Field</a></li><li><a class="tocitem" href="Components/ForceElements.html">Force Elements</a></li></ul></li><li class="is-active"><a class="tocitem" href="Functions.html">Functions</a><ul class="internal"><li><a class="tocitem" href="#D-Vectors"><span>3D Vectors</span></a></li><li><a class="tocitem" href="#Rotation-Matrices"><span>Rotation Matrices</span></a></li><li><a class="tocitem" href="#Quaternions"><span>Quaternions</span></a></li><li><a class="tocitem" href="#Frame-Transformations"><span>Frame Transformations</span></a></li><li><a class="tocitem" href="#Frame-Interpolations"><span>Frame Interpolations</span></a></li></ul></li><li><span class="tocitem">Internal</span><ul><li><a class="tocitem" href="internal/Profiling.html">Profiling</a></li><li><a class="tocitem" href="internal/DynamicDispatch.html">Dynamic Dispatch</a></li><li><a class="tocitem" href="internal/ContactDetection.html">Contact Detection</a></li><li><a class="tocitem" href="internal/ContactForceLaw.html">Contact Force Law</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="Functions.html">Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="Functions.html">Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ModiaSim/Modia3D.jl/blob/main/docs/src/Functions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h1><h2 id="D-Vectors"><a class="docs-heading-anchor" href="#D-Vectors">3D Vectors</a><a id="D-Vectors-1"></a><a class="docs-heading-anchor-permalink" href="#D-Vectors" title="Permalink"></a></h2><p>Functions to construct 3D vectors <code>v::SVector{3,F}</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.ZeroVector3D" href="#Modia3D.Frames.ZeroVector3D"><code>Modia3D.Frames.ZeroVector3D</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Modia3D.ZeroVector3D(::Type{F}) where F = SVector{3,F}(0, 0, 0)</code></pre><p>Constant of a SVector{3,Float64} where all elements are zero</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/vector3D.jl#L8-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.axisValue" href="#Modia3D.Frames.axisValue"><code>Modia3D.Frames.axisValue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vec = Modia3D.axisValue(axis, value::F) where F
vec = Modia3D.axisValue(axis, positive, value::F) where F</code></pre><p>Return <code>vec::SVector{3,F}</code> where all elements are zero with exception of <code>vec[axis] = value</code> or <code>vec[axis] = positive ? value : -value</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/vector3D.jl#L17-L23">source</a></section></article><h2 id="Rotation-Matrices"><a class="docs-heading-anchor" href="#Rotation-Matrices">Rotation Matrices</a><a id="Rotation-Matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Rotation-Matrices" title="Permalink"></a></h2><p>Functions to construct rotation matrices <code>R::SMatrix{3,3,F,9}</code> rotating a coordinate-system/frame 1 into a coordinate-system/frame 2.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.NullRotation"><code>Modia3D.NullRotation</code></a>(::Type{F})</td><td style="text-align: left">No rotation from frame 1 to frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.assertRotationMatrix"><code>Modia3D.assertRotationMatrix</code></a>(R)</td><td style="text-align: left">Assert that R is a rotation matrix</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot1"><code>Modia3D.rot1</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along x-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot2"><code>Modia3D.rot2</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along y-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot3"><code>Modia3D.rot3</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along z-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot123"><code>Modia3D.rot123</code></a>(angle1, angle2, angle3)</td><td style="text-align: left">Rotate around angles along x,y,z-axes</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot123"><code>Modia3D.rot123</code></a>(angles)</td><td style="text-align: left">Rotate around angles along x,y,z-axes</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rotAxis"><code>Modia3D.rotAxis</code></a>(axis,angle)</td><td style="text-align: left">Rotate around <code>angle</code> along <code>axis</code> (= 1,2,3)</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rotAxis"><code>Modia3D.rotAxis</code></a>(axis,positive,angle)</td><td style="text-align: left">Rotate around <code>angle</code> if <code>positive</code>, else <code>-angle</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot_e"><code>Modia3D.rot_e</code></a>(e, angle)</td><td style="text-align: left">Rotate around <code>angle</code> along unit vector <code>e</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot_nxy"><code>Modia3D.rot_nxy</code></a>(nx, ny)</td><td style="text-align: left"><code>nx</code>/<code>ny</code> are in x/y-direction of frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.rot_nxz"><code>Modia3D.rot_nxz</code></a>(nx, nz)</td><td style="text-align: left"><code>nx</code>/<code>nz</code> are in x/z-direction of frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.from_q"><code>Modia3D.from_q</code></a>(q)</td><td style="text-align: left">Return rotation matrix from quaternion <code>q</code></td></tr></table><p>Examples</p><pre><code class="language-julia hljs">using Modia3D

# R1,R2,R3 are the same RotationMatrices
R1 = Modia3D.rot1(pi/2)
R2 = Modia3D.rot1(90u&quot;°&quot;)
R3 = Modia3D.rot_e([1,0,0], pi/2)</code></pre><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.NullRotation" href="#Modia3D.Frames.NullRotation"><code>Modia3D.Frames.NullRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.MullRotation(::Type{F}) where F</code></pre><p>Return rotation matrix <code>R::SMatrix{3,3,F,9}</code> that defines no rotation from frame 1 to frame 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.assertRotationMatrix" href="#Modia3D.Frames.assertRotationMatrix"><code>Modia3D.Frames.assertRotationMatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Modia3D.assertRotationMatrix(R::AbstractMatrix)</code></pre><p>Assert that matrix R has the properties of a rotation matrix (is 3x3 and R&#39;*R - eye(3) = zeros(3,3))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L20-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot1" href="#Modia3D.Frames.rot1"><code>Modia3D.Frames.rot1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot1(angle)</code></pre><p>Return rotation matrix R that rotates with angle <code>angle</code> along the x-axis of frame 1. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot1(90u&quot;°&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L32-L37">source</a></section><section><div><pre><code class="nohighlight hljs">Modia3D.rot1(angle,v::AbstractVector)</code></pre><p>Return in principal Modia3D.rot1(angle)*v, but compute this efficiently by taking the zeros in rot1(..) into account. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot1(90u&quot;°&quot;, v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L47-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot2" href="#Modia3D.Frames.rot2"><code>Modia3D.Frames.rot2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot2(angle)</code></pre><p>Return rotation matrix R that rotates with angle <code>angle</code> along the y-axis of frame 1. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot2(90u&quot;°&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L60-L65">source</a></section><section><div><pre><code class="nohighlight hljs">Modia3D.rot2(angle,v::AbstractVector)</code></pre><p>Return in principal Modia3D.rot2(angle)*v, but compute this efficiently by taking the zeros in rot2(..) into account. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot2(90u&quot;°&quot;, v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot3" href="#Modia3D.Frames.rot3"><code>Modia3D.Frames.rot3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot3(angle)</code></pre><p>Return rotation matrix R that rotates with angle <code>angle</code> along the z-axis of frame 1. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot3(90u&quot;°&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L88-L93">source</a></section><section><div><pre><code class="nohighlight hljs">Modia3D.rot3(angle,v::AbstractVector)</code></pre><p>Return in principal Modia3D.rot3(angle)*v, but compute this efficiently by taking the zeros in rot3(..) into account. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rot3(90u&quot;°&quot;, v)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L103-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot123" href="#Modia3D.Frames.rot123"><code>Modia3D.Frames.rot123</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot123(angle1, angle2, angle3)
R = Modia3D.rot123(angles)</code></pre><p>Return rotation matrix R by rotating with angle1 along the x-axis of frame 1, then with angle2 along the y-axis of this frame and then with angle3 along the z-axis of this frame. The angles can be optionally provided in form of a vector <code>angles = [angle1, angle2, angle3]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L116-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rotAxis" href="#Modia3D.Frames.rotAxis"><code>Modia3D.Frames.rotAxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rotAxis(axis, angle)
R = Modia3D.rotAxis(axis, positive, angle)</code></pre><p>Return rotation matrix R that rotates with angle <code>angle</code> along axis <code>axis</code> (= 1, 2 or 3), or with <code>angle</code> if <code>positive=true</code> and otherwise with <code>-angle</code>. <code>angle</code> can be provided in radian or in degree, e.g. <code>using Unitful; Modia3D.rotAxis(2, 90u&quot;°&quot;)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L129-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot_e" href="#Modia3D.Frames.rot_e"><code>Modia3D.Frames.rot_e</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot_e(e, angle)</code></pre><p>Return rotation matrix that rotates frame1 around <code>angle</code> along unit axis <code>e</code> arriving at frame2. This function assumes that <code>norm(e) == 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L145-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot_nxy" href="#Modia3D.Frames.rot_nxy"><code>Modia3D.Frames.rot_nxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot_nxy(nx, ny)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>ny</code> are resolved in frame 1 and are directed along the x and y axis of frame 2. The function returns the rotation matrix R to rotate from frame 1 to frame 2.</p><p>The function is robust in the sense that it returns always a rotation matrix R, even if <code>ny</code> is not orthogonal to <code>nx</code> or if one or both vectors have zero length. This is performed in the following way: If <code>nx</code> and <code>ny</code> are not orthogonal to each other, first a unit vector <code>ey</code> is determined that is orthogonal to <code>nx</code> and is lying in the plane spanned by <code>nx</code> and <code>ny</code>. If <code>nx</code> and <code>ny</code> are parallel or nearly parallel to each other or <code>ny</code> is a vector with zero or nearly zero length, a vector <code>ey</code> is selected arbitrarily such that <code>ex</code> and <code>ey</code> are orthogonal to each other. If both <code>nx</code> and <code>ny</code> are vectors with zero or nearly zero length, an arbitrary rotation matrix is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Unitful
import Modia3D

R1 = Modia3D.rot1(90u&quot;°&quot;)
R2 = Modia3D.rot_nxy([1  , 0, 0], [0  , 0, 1  ])
R3 = Modia3D.rot_nxy([0.9, 0, 0], [1.1, 0, 1.1])
isapprox(R1,R2)   # returns true
isapprox(R1,R3)   # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L158-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.rot_nxz" href="#Modia3D.Frames.rot_nxz"><code>Modia3D.Frames.rot_nxz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.rot_nxz(nx, nz)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>nz</code> are resolved in frame 1 and are directed along the x and y axis of frame 2. The function returns the rotation matrix R to rotate from frame 1 to frame 2.</p><p>The function is robust in the sense that it returns always a rotation matrix R, even if <code>nx</code> is not orthogonal to <code>nz</code> or if one or both vectors have zero length. This is performed in the following way: If <code>nx</code> and <code>nz</code> are not orthogonal to each other, first a unit vector <code>ex</code> is determined that is orthogonal to <code>nz</code> and is lying in the plane spanned by <code>nx</code> and <code>nz</code>. If <code>nx</code> and <code>nz</code> are parallel or nearly parallel to each other or <code>nx</code> is a vector with zero or nearly zero length, a vector <code>ex</code> is selected arbitrarily such that <code>ex</code> and <code>ez</code> are orthogonal to each other. If both <code>nx</code> and <code>nz</code> are vectors with zero or nearly zero length, an arbitrary rotation matrix is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Unitful
import Modia3D

R1 = Modia3D.rot3(90u&quot;°&quot;)
R2 = Modia3D.rot_nxz([0, 1  , 0  ], [0, 0, 1  ])
R3 = Modia3D.rot_nxz([0, 1.1, 1.1], [0, 0, 0.9])
isapprox(R1,R2)   # returns true
isapprox(R1,R3)   # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L202-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.from_q" href="#Modia3D.Frames.from_q"><code>Modia3D.Frames.from_q</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R = Modia3D.from_q(q)</code></pre><p>Return rotation matrix <code>R::SMatrix{3,3,F,9}</code> from quaternions <code>q::SVector{4,F}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L44-L48">source</a></section></article><h2 id="Quaternions"><a class="docs-heading-anchor" href="#Quaternions">Quaternions</a><a id="Quaternions-1"></a><a class="docs-heading-anchor-permalink" href="#Quaternions" title="Permalink"></a></h2><p>Functions to construct quaternions <code>q::SVector{4,F}</code> rotating a coordinate-system/frame 1 into a coordinate-system/frame 2.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.NullQuaternion"><code>Modia3D.NullQuaternion</code></a>(::Type{F})</td><td style="text-align: left">No rotation from frame 1 to frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.assertQuaternion"><code>Modia3D.assertQuaternion</code></a>(q)</td><td style="text-align: left">Assert that q is a quaternion</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot1"><code>Modia3D.qrot1</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along x-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot2"><code>Modia3D.qrot2</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along y-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot3"><code>Modia3D.qrot3</code></a>(angle)</td><td style="text-align: left">Rotate around <code>angle</code> along z-axis</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot123"><code>Modia3D.qrot123</code></a>(angle1, angle2, angle3)</td><td style="text-align: left">Rotate around angles along x,y,z-axes</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot_e"><code>Modia3D.qrot_e</code></a>(e, angle)</td><td style="text-align: left">Rotate around <code>angle</code> along unit vector <code>e</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot_nxy"><code>Modia3D.qrot_nxy</code></a>(nx, ny)</td><td style="text-align: left"><code>nx</code>/<code>ny</code> are in x/y-direction of frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.qrot_nxz"><code>Modia3D.qrot_nxz</code></a>(nx, nz)</td><td style="text-align: left"><code>nx</code>/<code>nz</code> are in x/z-direction of frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.from_R"><code>Modia3D.from_R</code></a>(R)</td><td style="text-align: left">Return <code>q</code> from rotation matrix <code>R</code></td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.NullQuaternion" href="#Modia3D.Frames.NullQuaternion"><code>Modia3D.Frames.NullQuaternion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">const Modia3D.NullQuaternion(F) = SVector{4,F}(0.0, 0.0, 0.0, 1.0)</code></pre><p>Constant quaternion vector of a null rotation (= no rotation from frame 1 to frame 2)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.assertQuaternion" href="#Modia3D.Frames.assertQuaternion"><code>Modia3D.Frames.assertQuaternion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Modia3D.assertQuaternion(q::AbstractVector)</code></pre><p>Assert that vector <code>q</code> has the properties of a quaternion vector (has 4 elements, <code>norm(q) = 1</code>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot1" href="#Modia3D.Frames.qrot1"><code>Modia3D.Frames.qrot1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot1(angle; q_guess = NullQuaternion(F))</code></pre><p>Return quaternion <code>q</code> that rotates with angle <code>angle</code> along the x-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot2" href="#Modia3D.Frames.qrot2"><code>Modia3D.Frames.qrot2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot2(angle; q_guess = NullQuaternion(F))</code></pre><p>Return quaternion <code>q</code> that rotates with angle <code>angle</code> along the y-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L113-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot3" href="#Modia3D.Frames.qrot3"><code>Modia3D.Frames.qrot3</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot3(angle; q_guess = NullQuaternion(F))</code></pre><p>Return quaternion <code>q</code> that rotates with angle <code>angle</code> along the z-axis of frame 1.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L127-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot123" href="#Modia3D.Frames.qrot123"><code>Modia3D.Frames.qrot123</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot123(angle1, angle2, angle3)</code></pre><p>Return quaternion <code>q</code> by rotating with angle1 along the x-axis of frame 1, then with angle2 along the y-axis of this frame and then with angle3 along the z-axis of this frame.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L148-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot_e" href="#Modia3D.Frames.qrot_e"><code>Modia3D.Frames.qrot_e</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot_e(e, angle; q_guess = NullQuaternion(F))</code></pre><p>Return quaternion <code>q</code> that rotates with angle <code>angle</code> along unit axis <code>e</code>. This function assumes that <code>norm(e) == 1</code>.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L162-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot_nxy" href="#Modia3D.Frames.qrot_nxy"><code>Modia3D.Frames.qrot_nxy</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot_nxy(nx, ny)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>ny</code> are resolved in frame 1 and are directed along the x and y axis of frame 2. The function returns the quaternion <code>q</code> to rotate from frame 1 to frame 2.</p><p>The function is robust in the sense that it returns always a quaternion <code>q</code>, even if <code>ny</code> is not orthogonal to <code>nx</code> or if one or both vectors have zero length. This is performed in the following way: If <code>nx</code> and <code>ny</code> are not orthogonal to each other, first a unit vector <code>ey</code> is determined that is orthogonal to <code>nx</code> and is lying in the plane spanned by <code>nx</code> and <code>ny</code>. If <code>nx</code> and <code>ny</code> are parallel or nearly parallel to each other or <code>ny</code> is a vector with zero or nearly zero length, a vector <code>ey</code> is selected arbitrarily such that <code>ex</code> and <code>ey</code> are orthogonal to each other. If both <code>nx</code> and <code>ny</code> are vectors with zero or nearly zero length, an arbitrary quaternion <code>q</code> is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Unitful
import Modia3D

q1 = Modia3D.qrot1(90u&quot;°&quot;)
q2 = Modia3D.qrot_nxy([1  , 0, 0], [0  , 0, 1  ])
q3 = Modia3D.qrot_nxy([0.9, 0, 0], [1.1, 0, 1.1])
isapprox(q1,q2)   # returns true
isapprox(q1,q3)   # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L179-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.qrot_nxz" href="#Modia3D.Frames.qrot_nxz"><code>Modia3D.Frames.qrot_nxz</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.qrot_nxz(nx, nz)</code></pre><p>It is assumed that the two input vectors <code>nx</code> and <code>nz</code> are resolved in frame 1 and are directed along the x and z axis of frame 2. The function returns the quaternion <code>q</code> to rotate from frame 1 to frame 2.</p><p>The function is robust in the sense that it returns always a quaternion <code>q</code>, even if <code>nx</code> is not orthogonal to <code>nz</code> or if one or both vectors have zero length. This is performed in the following way: If <code>nx</code> and <code>nz</code> are not orthogonal to each other, first a unit vector <code>ex</code> is determined that is orthogonal to <code>nz</code> and is lying in the plane spanned by <code>nx</code> and <code>nz</code>. If <code>nx</code> and <code>nz</code> are parallel or nearly parallel to each other or <code>nx</code> is a vector with zero or nearly zero length, a vector <code>ex</code> is selected arbitrarily such that <code>ex</code> and <code>ez</code> are orthogonal to each other. If both <code>nx</code> and <code>nz</code> are vectors with zero or nearly zero length, an arbitrary quaternion <code>q</code> is returned.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">using Unitful
import Modia3D

q1 = Modia3D.qrot3(90u&quot;°&quot;)
q2 = Modia3D.qrot_nxz([0, 1  , 0  ], [0, 0, 1  ])
q3 = Modia3D.qrot_nxz([0, 1.1, 1.1], [0, 0, 0.9])
isapprox(q1,q2)   # returns true
isapprox(q1,q3)   # returns true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L215-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.from_R" href="#Modia3D.Frames.from_R"><code>Modia3D.Frames.from_R</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">q = Modia3D.from_R(R; q_guess = NullQuaternion(F))</code></pre><p>Return quaternion <code>q::SVector{4,F}</code> from rotation matrix <code>R::SMatrix{3,3,F,9}</code>.</p><p>From the two possible solutions <code>q</code> the one is returned that is closer to <code>q_guess</code> (note, <code>q</code> and <code>-q</code> define the same rotation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/quaternion.jl#L60-L67">source</a></section></article><h2 id="Frame-Transformations"><a class="docs-heading-anchor" href="#Frame-Transformations">Frame Transformations</a><a id="Frame-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-Transformations" title="Permalink"></a></h2><p>Functions to transform vectors, rotation matrices, quaternions between coordinate systems and functions to determine properties from coordinate system transformations.</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.resolve1"><code>Modia3D.resolve1</code></a>(rot, v2)</td><td style="text-align: left">Transform vector <code>v</code> from frame 2 to frame 1</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.resolve2"><code>Modia3D.resolve2</code></a>(rot, v1)</td><td style="text-align: left">Transform vector <code>v</code> from frame 1 to frame 2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.absoluteRotation"><code>Modia3D.absoluteRotation</code></a>(rot01, rot12)</td><td style="text-align: left">Return rotation 0-&gt;2 from rot. 0-&gt;1 and 1-&gt;2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.relativeRotation"><code>Modia3D.relativeRotation</code></a>(rot01, rot02)</td><td style="text-align: left">Return rotation 1-&gt;2 from rot. 0-&gt;1 and 0-&gt;2</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.inverseRotation"><code>Modia3D.inverseRotation</code></a>(rot01)</td><td style="text-align: left">Return rotation 1-&gt;0 from rot, 0-&gt;1</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.planarRotationAngle"><code>Modia3D.planarRotationAngle</code></a>(e,v1,v2)</td><td style="text-align: left">Return angle of planar rotation along <code>e</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.eAxis"><code>Modia3D.eAxis</code></a>(axis)</td><td style="text-align: left">Return unit vector <code>e</code> in direction of <code>axis</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.skew"><code>Modia3D.skew</code></a>(v)</td><td style="text-align: left">Return skew-symmetric matrix of vector v</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.resolve1" href="#Modia3D.Frames.resolve1"><code>Modia3D.Frames.resolve1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">v1 = Modia3D.resolve1(R, v2)
v1 = Modia3D.resolve1(q, v2)
v1 = Modia3D.resolve1(rotation, v2; rotationXYZ=true)</code></pre><p>Transform vector <code>v2::AbstractVector</code> (vector resolved in frame 2) to vector <code>v1::SVector{3,F}</code> (vector resolved in frame 1) given</p><ul><li>Rotation matrix <code>R::SMatrix{3,3,F,9}</code> (rotate frame 1 into frame 2) or</li><li>Quaternion vector <code>q::SVector{4,F}</code> (rotate frame 1 into frame 2) or</li><li>Angles vector <code>rotation::AbstractVector</code> (rotationXYZ=true: rotate around X with rotation[1], around Y with rotation[2], around Z with rotation[3];  rotationXYZ=false: rotate around X with rotation[1], around Z with rotation[2], around Y with rotation[3]).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L246-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.resolve2" href="#Modia3D.Frames.resolve2"><code>Modia3D.Frames.resolve2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">v2 = Modia3D.resolve2(R, v1)
v2 = Modia3D.resolve2(q, v1)
v2 = Modia3D.resolve2(rotation, v1; rotationXYZ=true)</code></pre><p>Transform vector <code>v1::AbstractVector</code> (vector resolved in frame 1) to vector <code>v2::SVector{3,F}</code> (vector resolved in frame 2) given</p><ul><li>Rotation matrix <code>R::SMatrix{3,3,F,9}</code> (rotate frame 1 into frame 2) or</li><li>Quaternion vector <code>q::SVector{4,F}</code> (rotate frame 1 into frame 2) or</li><li>Angles vector <code>rotation::AbstractVector</code> (rotationXYZ=true: rotate around X with rotation[1], around Y with rotation[2], around Z with rotation[3];  rotationXYZ=false: rotate around X with rotation[1], around Z with rotation[2], around Y with rotation[3]).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L267-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.absoluteRotation" href="#Modia3D.Frames.absoluteRotation"><code>Modia3D.Frames.absoluteRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> R2 = Modia3D.absoluteRotation(R1, R_rel)
 q2 = Modia3D.absoluteRotation(q1, q_rel)</code></pre><p>Return rotation matrix <code>R2</code> or quaternion <code>q2</code> defining the rotation from frame 0 to frame 2 from rotation matrix <code>R1</code> or quaternion <code>q1</code>that define the rotation from frame 0 to frame 1 and the relative rotation matrix <code>R_rel</code> or the relative quaternion <code>q_rel</code> that define the rotation from frame 1 to frame 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L300-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.relativeRotation" href="#Modia3D.Frames.relativeRotation"><code>Modia3D.Frames.relativeRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> R_rel = Modia3D.relativeRotation(R1, R2)
 q_rel = Modia3D.relativeRotation(q1, q2)</code></pre><p>Return relative rotation matrix <code>R_rel</code> or relative quaternion <code>q_rel</code> defining the rotation from frame 1 to frame 2 from absolute rotation matrix <code>R1</code> or absolute quaternion <code>q1</code> that define the rotation from frame 0 to frame 1 and the absolute rotation matrix <code>R2</code> or the absolute quaternion <code>q2</code> that define the rotation from frame 0 to frame 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L313-L322">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.inverseRotation" href="#Modia3D.Frames.inverseRotation"><code>Modia3D.Frames.inverseRotation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> R_inv = Modia3D.inverseRotation(R)
 q_inv = Modia3D.inverseRotation(q)</code></pre><p>Return inverse rotation matrix <code>R_inv</code> or inverse quaternion <code>q_inv</code> defining the rotation from frame 1 to frame 0 from rotation matrix <code>R</code> or quaternion <code>q</code> that define the rotation from frame 0 to frame 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L326-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.planarRotationAngle" href="#Modia3D.Frames.planarRotationAngle"><code>Modia3D.Frames.planarRotationAngle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">angle = planarRotationAngle(e, v1, v2; angle_guess = 0.0)</code></pre><p>Return <code>angle</code> of a planar rotation, given the normalized axis of rotation to rotate frame 1 around <code>e</code> into frame 2 (norm(e) == 1 required), and the representations of a vector in frame 1 (<code>v1</code>) and frame 2 (<code>v2</code>). Hereby, it is required that <code>v1</code> is not parallel to <code>e</code>. The returned angle is in the range <code>-pi &lt;= angle - angle_guess &lt;= pi</code> (from the infinite many solutions, the one is returned that is closest to <code>angle_guess</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import Modia3D
using Unitful

angle1 = 45u&quot;°&quot;
e      = normalize([1.0, 1.0, 1.0])
R      = Modia3D.rot_e(e, angle1)

v1 = [1.0, 2.0, 3.0]
v2 = Modia3D.resolve2(R, v1)

angle2 = planarRotationAngle(e, v1, v2)
isapprox(angle1, angle2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L338-L364">source</a></section><section><div><pre><code class="nohighlight hljs">angle = planarRotationAngle(frame1, frame2)</code></pre><p>Under the assumption that the z-axes of frame1 and frame2 coincide, return the angle between the x-axis of frame1 and the position vector from frame1 to frame2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Composition/sensors.jl#L12-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.eAxis" href="#Modia3D.Frames.eAxis"><code>Modia3D.Frames.eAxis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">e = eAxis(::Type{F}, axis::Int)</code></pre><p>Return unit vector <code>e::SVector{3,F}</code> in direction of axis <code>axis</code> (<code>axis</code> = 1,2,3 or -1,-2-,3).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import Modia3D

e1 = ModiMath.eAxis(1)    # e1 = SVector{3,F}(1.0,  0.0, 0.0)
e2 = ModiMath.eAxis(-2)   # d2 = SVector{3,F}(0.0, -1.0, 0.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/rotationMatrix.jl#L427-L441">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.skew" href="#Modia3D.Frames.skew"><code>Modia3D.Frames.skew</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">M = Modia3D.skew(e::SVector{3,F}) where F
M = Modia3D.skew(e::Vector{F})    where F</code></pre><p>Return the skew symmetric matrix <code>M</code> of vector <code>e</code> (<code>length(e) = 3</code>) with</p><pre><code class="language-julia hljs">M = @SMatrix [  F(0.0)  -e[3]    e[2];
                e[3]    F(0.0)  -e[1];
               -e[2]     e[1]   F(0.0) ]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/vector3D.jl#L34-L45">source</a></section></article><h2 id="Frame-Interpolations"><a class="docs-heading-anchor" href="#Frame-Interpolations">Frame Interpolations</a><a id="Frame-Interpolations-1"></a><a class="docs-heading-anchor-permalink" href="#Frame-Interpolations" title="Permalink"></a></h2><p>Given a set of coordinate-systems/frames by a vector <code>r</code> of position vectors (to their origins) and and an optional vector <code>q</code> of Quaternions (of their absolute orientations), then the following functions interpolate linearly in these frames:</p><table><tr><th style="text-align: left">Function</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.Path"><code>Modia3D.Path</code></a>(r,q)</td><td style="text-align: left">Return path defined by a vector of frames</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.t_pathEnd"><code>Modia3D.t_pathEnd</code></a>(path)</td><td style="text-align: left">Return path parameter <code>t_end</code> of last frame</td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.interpolate"><code>Modia3D.interpolate</code></a>(path,t)</td><td style="text-align: left">Return <code>(rt,qt)</code> of Path at path parameter <code>t</code></td></tr><tr><td style="text-align: left"><a href="Functions.html#Modia3D.Frames.interpolate_r"><code>Modia3D.interpolate_r</code></a>(path,t)</td><td style="text-align: left">Return <code>rt</code> of Path at path parameter <code>t</code></td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.Path" href="#Modia3D.Frames.Path"><code>Modia3D.Frames.Path</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">path = Modia3D.Path(r::Vector{SVector{3,Float64}},
                    q::Vector{SVector{4,Float64}} = NullQuaternion(Float64);
                    v = ones(length(r)))</code></pre><p>Return an instance of a new Path object. The Path object consists of n frames defined by the position vectors of their origins (<code>r[i]</code> for frame <code>i</code>) and optionally of their absolute rotation quaternions (<code>q[i]</code> for frame <code>i</code>) describing the rotation from the world frame to the respective frame.</p><p>A path parameter <code>t</code> is defined in the following way on these frames:</p><ul><li><code>t[1] = 0.0</code>.</li><li><code>t[i] = t[i-1] + pathLength_i/(v[i]+v[i-1])/2</code> if the origins of frames <code>i-1</code> and <code>i</code> do not coincide.</li><li><code>t[i] = t[i-1] + pathAngle_i/(v[i]+v[i-1])/2</code> if the origins of frames <code>i-1</code> and <code>i</code> do coincide.</li></ul><p>Hereby <code>pathLength_i</code> is the distance between the origins of frames <code>i-1</code> and <code>i</code> in [m] and <code>pathAngle_i</code> is the planar rotation angle between frames <code>i-1</code> and <code>i</code> in [rad].</p><p>If <code>v[i]</code> is the desired velocity or angular velocity at frame <code>i</code>, then path parameter <code>t</code> is approximately the time to move along the path. The time instant <code>t_end</code> of the last frame can be inquired with <code>Modia3D.t_pathEnd(path)</code>. For example, if a simulation shall be performed in such a way that the simulation should start with the first frame and end at <code>stopTime</code> at the last frame, then the path parameter should be selected as <code>t = time*t_end/stopTime</code>.</p><p>Given the actual path parameter, typically <code>0 &lt;= t &lt;= t_end</code> (if <code>t</code> is outside of this interval, the frame at <code>t</code> is determined by extrapolation through the first two or the last two frames), the corresponding frame is determined by linear interpolation in the following way:</p><pre><code class="language-julia hljs">(rt, qt) = interpolate(  path,t)
 rt      = interpolate_r(path,t)</code></pre><p>where <code>rt</code> is the position vector to the origin of the frame at path parameter <code>t</code> and <code>qt</code> is the absolute quaternion of the frame at path parameter <code>t</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">import Modia3D
using Unitful

r = [ SVector{3,F}(1,0,0),
      SVector{3,F}(0,1,0),
      SVector{3,F}(0,0,1) ]
q = [ Modia3D.NullQuaternion(F),
      Modia3D.qrot1(45u&quot;°&quot;),
      Modia3D.qrot2(60u&quot;°&quot;)]

path     = Modia3D.Path(r,q)
t_end    = Modia3D.t_pathEnd(path)
dt       = 0.1
stopTime = 2.0
time     = 0.0

while time &lt;= stopTime
   (rt, qt) = Modia3D.interpolate(path, time*t_end/stopTime)
   time += dt
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/interpolation.jl#L9-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.t_pathEnd" href="#Modia3D.Frames.t_pathEnd"><code>Modia3D.Frames.t_pathEnd</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">t_end = Modia3D.t_pathEnd(path::[`Modia3D.Path`](@ref))</code></pre><p>Return the final path parameter <code>t</code>of the last frame in path (path parameter of first frame = 0.0).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/interpolation.jl#L121-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.interpolate" href="#Modia3D.Frames.interpolate"><code>Modia3D.Frames.interpolate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">(rt, qt) = Modia3D.interpolate(path, t)</code></pre><p>Return position <code>rt</code>and Quaternion <code>qt</code> of <code>path::</code><a href="Functions.html#Modia3D.Frames.Path"><code>Modia3D.Path</code></a> at path parameter <code>t::Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/interpolation.jl#L159-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Modia3D.Frames.interpolate_r" href="#Modia3D.Frames.interpolate_r"><code>Modia3D.Frames.interpolate_r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">rt = Modia3D.interpolate_r(path, t)</code></pre><p>Return position <code>r</code> of <code>path::</code><a href="Functions.html#Modia3D.Frames.Path"><code>Modia3D.Path</code></a> at path parameter <code>t::Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ModiaSim/Modia3D.jl/blob/a6813975fecd5453f062fe986ed846e3590db9ac/src/Frames/interpolation.jl#L177-L181">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="Components/ForceElements.html">« Force Elements</a><a class="docs-footer-nextpage" href="internal/Profiling.html">Profiling »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 30 May 2023 14:05">Tuesday 30 May 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
