var documenterSearchIndex = {"docs":
[{"location":"Components/GravityField.html#Gravity-Field","page":"Gravity Field","title":"Gravity Field","text":"","category":"section"},{"location":"Components/GravityField.html","page":"Gravity Field","title":"Gravity Field","text":"A global gravity field for the whole scene is defined with keyword gravitys in a Scene. Possible values:","category":"page"},{"location":"Components/GravityField.html#NoGravityField","page":"Gravity Field","title":"NoGravityField","text":"","category":"section"},{"location":"Components/GravityField.html","page":"Gravity Field","title":"Gravity Field","text":"NoGravityField","category":"page"},{"location":"Components/GravityField.html#Modia3D.Composition.NoGravityField","page":"Gravity Field","title":"Modia3D.Composition.NoGravityField","text":"gravityField = NoGravityField()\n\nGenerate an instance of type NoGravityField that defines no gravity.\n\n\n\n\n\n","category":"type"},{"location":"Components/GravityField.html#UniformGravityField","page":"Gravity Field","title":"UniformGravityField","text":"","category":"section"},{"location":"Components/GravityField.html","page":"Gravity Field","title":"Gravity Field","text":"Modia3D.Composition.UniformGravityField","category":"page"},{"location":"Components/GravityField.html#Modia3D.Composition.UniformGravityField","page":"Gravity Field","title":"Modia3D.Composition.UniformGravityField","text":"UniformGravityField(;g=9.81, n=[0,-1,0])\n\nGenerate an instance of type UniformGravityField that defines a uniform gravity field with gravitational acceleration g in direction n.\n\nArguments\n\ng::Float64: Gravitational acceleration\nn::AbstractVector: Direction of gravitational acceleration\n\nExample\n\nimport Modia3D\n\ngrav = Modia3D.Composition.UniformGravityField()\n   r = Modia3D.EarthRadius\n   g = gravityAcceleration(grav,r)  # g is independent of r\n\n\n\n\n\n","category":"type"},{"location":"Components/GravityField.html#PointGravityField","page":"Gravity Field","title":"PointGravityField","text":"","category":"section"},{"location":"Components/GravityField.html","page":"Gravity Field","title":"Gravity Field","text":"PointGravityField","category":"page"},{"location":"Components/GravityField.html#Modia3D.Composition.PointGravityField","page":"Gravity Field","title":"Modia3D.Composition.PointGravityField","text":"PointGravityField([mass|;mue=G*EarthMass])\n\nGenerate an instance of type PointGravityField that defines a point gravity field of mass or gravity field constant mue. The gravity center is located at the world origin, i.e. the gravitational acceleration decreases quadratically with distance from world.\n\nExample\n\nimport Modia3D\n\ngrav = Modia3D.PointGravityField()   # Gravity field of earth\n   r = Modia3D.EarthRadius\n   g = gravityAcceleration(grav,r)  # g is singular at r=0\n\n\n\n\n\n","category":"type"},{"location":"Components/Joints.html#Joints","page":"Joints","title":"Joints","text":"","category":"section"},{"location":"Components/Joints.html","page":"Joints","title":"Joints","text":"CurrentModule = Modia3D.Composition","category":"page"},{"location":"Components/Joints.html#Revolute","page":"Joints","title":"Revolute","text":"","category":"section"},{"location":"Components/Joints.html","page":"Joints","title":"Joints","text":"Revolute","category":"page"},{"location":"Components/Joints.html#Modia3D.Composition.Revolute","page":"Joints","title":"Modia3D.Composition.Revolute","text":"joint = Revolute(;obj1, obj2, path=\"\", axis=3, phi=0, w=0, canCollide=false)\n\nReturn a Revolute joint that rotates obj1::Object3D into obj2::Object3D along the axis axis of obj1 (axis = 1,2,3,-1,-2,-3). The initial start angle is phi and the initial angular velocity is w. Negative axis values describe axes in negative axis directions, i.e. the signs of the values of phi and w are reversed. If canCollide=false, no collision detection will occur between obj1 and obj2 (and Object3Ds that are directly or indirectly rigidly fixed to obj1 or obj2).\n\nIt is currently not supported that a Revolute joint closes a kinematic loop.\n\n\n\n\n\n","category":"type"},{"location":"Components/Joints.html#Prismatic","page":"Joints","title":"Prismatic","text":"","category":"section"},{"location":"Components/Joints.html","page":"Joints","title":"Joints","text":"Prismatic","category":"page"},{"location":"Components/Joints.html#Modia3D.Composition.Prismatic","page":"Joints","title":"Modia3D.Composition.Prismatic","text":"joint = Prismatic(; obj1, obj2, path=\"\", axis=1, s=0, v=0, canCollide=true)\n\nReturn a joint that translates obj2::Object3D with respect to obj1::Object3D along coordinate axis axis (axis = 1,2,3,-1,-2,-3) of obj1. The initial position is s and the initial velocity is v. Negative axis values describe axes in negative axis directions, i.e. the signs of the values of s and v are reversed. If canCollide=false, no collision detection will occur between obj1 and obj2 (and Object3Ds that are directly or indirectly rigidly fixed to obj1 or obj2).\n\nIt is currently not supported that a Prismatic joint closes a kinematic loop.\n\n\n\n\n\n","category":"type"},{"location":"Components/Joints.html#FreeMotion","page":"Joints","title":"FreeMotion","text":"","category":"section"},{"location":"Components/Joints.html","page":"Joints","title":"Joints","text":"FreeMotion","category":"page"},{"location":"Components/Joints.html#Modia3D.Composition.FreeMotion","page":"Joints","title":"Modia3D.Composition.FreeMotion","text":"joint = FreeMotion(; obj1, obj2, path=\"\", r, rot, v, w)\n\nReturn a joint that describes the free movement of obj2::Object3D with respect to obj1::Object3D. The initial position is r (resolved in obj1) and the initial orientation is rot in Cardan (Tait–Bryan) angles (rotation sequence x-y-z from obj1 to obj2). v (resolved in obj1) and w (resolved in obj2) are the initial cartesian translational and rotational velocity vectors.\n\n\n\n\n\n","category":"type"},{"location":"Components/Joints.html#Fix","page":"Joints","title":"Fix","text":"","category":"section"},{"location":"Components/Joints.html","page":"Joints","title":"Joints","text":"Fix","category":"page"},{"location":"Components/Joints.html#Modia3D.Composition.Fix","page":"Joints","title":"Modia3D.Composition.Fix","text":"obj = Fix(; obj1, obj2, translation=zeros(3), rotation=zeros(3))\n\nRigidly fix obj2::Object3D relatively to obj1::Object3D via the relative position vector translation from obj1 to obj2 (resolved in obj1) and the relative orientation angles rotation from obj1 to obj2.\n\nReturn obj=obj1, if obj2 is directly or indirectly connected to the world Object3D. Otherwise, return obj=obj2.\n\nArguments\n\nobj1::Object3D: Parent object.\nobj2::Object3D: Object fixed relative to obj1.\nr::AbstractVector: Relative position vector from obj1 to obj2  resolved in obj1.\nrot::AbstractVector: Relative orientation from obj1 to obj2  in Cardan (Tait–Bryan) angles  (rotation sequence x-y-z).\n\n\n\n\n\n","category":"type"},{"location":"internal/Profiling.html#Profiling","page":"Profiling","title":"Profiling","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"This section summarizes some techniques to determine timing and memory allocation measures for Modia3D. The various approaches are demonstrated with models from directory Modia3D/test/Profiling.","category":"page"},{"location":"internal/Profiling.html#@time","page":"Profiling","title":"@time","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The simplest technique is to put @time in front of the statement that should be measured, such as:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"# File Modia3D/test/Profiling/BouncingSphere_time.jl\r\n\r\nmodule BouncingSphereSimulation_time\r\n\r\n@time begin BouncingSphere = Model3D(\r\n    ...\r\n    )\r\nend\r\n\r\n@time bouncingSphere = @instantiateModel(...)\r\n@time simulate!(bouncingSphere,...)\r\n@time plot(bouncingSphere, ...)\r\nend","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"This gives the following output:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"  0.000116 seconds (199 allocations: 12.344 KiB)\r\n\r\nInstantiating model Main.BouncingSphereSimulation.BouncingSphere\r\n  1.106054 seconds (2.40 M allocations: 150.386 MiB, 3.92% gc time, 62.47% compilation time)\r\n  0.322050 seconds (579.29 k allocations: 32.774 MiB, 5.81% compilation time)\r\n  0.077613 seconds (1.74 k allocations: 97.844 KiB)","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The second line","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"  1.106054 seconds (2.40 M allocations: 150.386 MiB, 3.92% gc time, 62.47% compilation time)","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"means the following:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The total time spent in this statement was 1.106054 seconds\n62.47% of this time was used to compile Julia code.\n3.92% of this time was used by the garbage collector, so was used to find and remove allocated memory that is no longer in use.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"There have been 2.5 million allocations of memory. In total 150.386 Mega-Bytes have been allocated.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"If a @time output contains gc time and/or compilation time  it might be useful to just re-run the file, in order that the total time better reflects the execution time. In a second run compilation time should no longer be present.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Modia3D must allocate memory at the beginning of a simulate!(..) run for its internal data structure. After initialization, no memory should be allocated. However, with the @time macro it is not possible to figure out whether this is the case. Use instead option logTiming=true, see next section.","category":"page"},{"location":"internal/Profiling.html#logTiming","page":"Profiling","title":"logTiming","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Function simulate!(..., logTiming=true, ...) has keyword argument logTiming. When set to true, the result of the @timeit macro of the TimerOutputs package is shown. Function simulate!(..) and Modia3D are instrumented with this timer.  Example:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"# File Modia3D/test/Profiling/Mobile.jl\r\n\r\nmodule MobileWithLogTiming\r\n...\r\nconst enableVisualization = false\r\nconst tolerance = 1e-4\r\n...\r\n@time mobile = @instantiateModel(..., logExecution=true, ...)\r\n...\r\n@time simulate!(mobile, ...)\r\n@time simulate!(mobile, log=true, logTiming=true, ...)\r\nend","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The @time macro should be used for @instantiateModel and simulate! in order to get information, whether allocation of storage is due to compilation and/or garbage collection. If the second simulate!(..) shows such allocation, the profiling run should be repeated.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"@instantiateModel should have flag logExecution=true, in order that the generated function getDerivatives!(..) is called twice to force compilation of this function.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The logTiming=true flag generates the following output in this case:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Instantiating model Main.MobileWithLogTiming.Mobile\r\n\r\nExecute getDerivatives\r\nFirst executions of getDerivatives\r\n  1.363270 seconds (548.47 k allocations: 45.652 MiB, 2.47% gc time, 99.56% compilation time)\r\n  0.002773 seconds (18.82 k allocations: 1.157 MiB)\r\n  2.540190 seconds (7.17 M allocations: 264.371 MiB, 2.62% gc time, 53.43% compilation time)\r\n... first simulation:\r\n  8.341341 seconds (37.34 M allocations: 2.236 GiB, 3.36% gc time)\r\n... second simulation:\r\n... Simulate model Mobile\r\n      Initialization at time = 0.0 s\r\n      Termination of Mobile at time = 5.0 s\r\n        cpuTime         = 11.7 s\r\n        allocated       = 2290.0 MiB\r\n        algorithm       = CVODE_BDF\r\n        FloatType       = Float64\r\n        interval        = 0.01 s\r\n        tolerance       = 0.0001 (relative tolerance)\r\n        nStates         = 188\r\n        nResults        = 501\r\n        nGetDerivatives = 1968 (total number of getDerivatives! calls)\r\n        nf              = 1465 (number of getDerivatives! calls from integrator)\r\n        nZeroCrossings  = 0 (number of getDerivatives! calls for zero crossing detection)\r\n        nJac            = 6 (number of Jacobian computations)\r\n        nAcceptedSteps  = 281\r\n        nRejectedSteps  = 3\r\n        nErrTestFails   = 3\r\n        nTimeEvents     = 0\r\n        nStateEvents    = 0\r\n        nRestartEvents  = 0\r\n\r\n... Timings for simulation of Mobile:\r\n ──────────────────────────────────────────────────────────────────────────────────────────────\r\n                                                       Time                   Allocations\r\n                                               ──────────────────────   ───────────────────────\r\n               Tot / % measured:                    11.8s / 99.0%           2.24GiB / 100%\r\n\r\n Section                               ncalls     time   %tot     avg     alloc   %tot      avg\r\n ──────────────────────────────────────────────────────────────────────────────────────────────\r\n simulate!                                  1    11.7s   100%   11.7s   2.24GiB  100%   2.24GiB\r\n solve                                      1    11.7s   100%   11.7s   2.23GiB  100%   2.23GiB\r\n getDerivatives!                        1.97k    11.7s   100%  5.93ms   2.24GiB  100%   1.16MiB\r\n LinearEquationsIteration               1.97k    11.6s  99.3%  5.91ms   2.22GiB  99.4%  1.16MiB\r\n luA ldiv!                              1.97k    4.65s  39.7%  2.36ms   1.68MiB  0.07%     896B\r\n Modia3D                                 189k    3.56s  30.4%  18.8μs    905KiB  0.04%    4.90B\r\n Modia3D_2                               185k    2.57s  22.0%  13.9μs   5.16KiB  0.00%    0.03B\r\n Modia3D_2 computeForcesAndResiduals     185k    638ms  5.45%  3.45μs     0.00B  0.00%    0.00B\r\n Modia3D_2 computeKinematics!            185k    566ms  4.83%  3.06μs     0.00B  0.00%    0.00B\r\n Modia3D_1                              1.97k   50.3ms  0.43%  25.6μs   5.16KiB  0.00%    2.68B\r\n Modia3D_1 computeKinematics!           1.97k   22.4ms  0.19%  11.4μs     0.00B  0.00%    0.00B\r\n init!                                      1   9.46ms  0.08%  9.46ms   2.03MiB  0.09%  2.03MiB\r\n Modia3D_1 computeForcesAndResiduals    1.97k   8.00ms  0.07%  4.07μs     0.00B  0.00%    0.00B\r\n Modia3D_3                              1.97k    584μs  0.00%   297ns     0.00B  0.00%    0.00B\r\n ODEProblem                                 1   38.2μs  0.00%  38.2μs   2.58KiB  0.00%  2.58KiB\r\n Modia3D_4 isTerminal                       1    400ns  0.00%   400ns     0.00B  0.00%    0.00B\r\n ──────────────────────────────────────────────────────────────────────────────────────────────\r\n 11.999957 seconds (37.34 M allocations: 2.237 GiB, 2.67% gc time)","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The meaning of the first lines","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"First executions of getDerivatives\r\n  1.363270 seconds (548.47 k allocations: 45.652 MiB, 2.47% gc time, 99.56% compilation time)\r\n  0.002773 seconds (18.82 k allocations: 1.157 MiB)\r\n  2.540190 seconds (7.17 M allocations: 264.371 MiB, 2.62% gc time, 53.43% compilation time)","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"is the following:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"1.363270 seconds is the time for the first evaluation of getDerivatives!. This time is nearly completely used for compilation of this function\n0.002773 seconds is the time for the second evaluation of getDerivatives!. This time is nearly irrelevant for the timing of @instantiateModel.\n2.540190 seconds is the total time spent in @instantiateModel, including the two calls of getDerivatives!. This time, together with (1.) shows the following:\n0.47*2.5 = 1.1 seconds are used to process the model, generate getDerivatives! and process getDerivatives! twice.\n0.53*2.5 = 1.32 seconds are used to compile getDerivatives!.","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The meaning of column Section is the following:","category":"page"},{"location":"internal/Profiling.html#@timeit-instrumentation-of-simulate!(..)","page":"Profiling","title":"@timeit instrumentation of simulate!(..)","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Column Section Description\nsimulate! Time of simulate!(..), but without log outputs.\ninit! Time of init!(..), so model initialization.\nODEProblem Time of DifferentialEquations.ODEProblem(..), so setup of problem.\nsolve Time of DifferentialEquations.solve(..), so after init!(..).\ngetDerivatives! Time of getDerivatives!(..).\nLinearEquationsIteration Time to build and solve linear equation systems inside getDerivatives!(..)\nluA ldiv! Time to solve A*x=b with luA and ldiv! inside LinearEquationsIteration","category":"page"},{"location":"internal/Profiling.html#@timeit-instrumentation-of-Modia3D","page":"Profiling","title":"@timeit instrumentation of Modia3D","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Column Section Description\nModia3D Total time spent in Modia3D functions.\nModia3D_0 initializeVisualization Time to initialize visualization (during init!(..)).\nModia3D_1 Time of leq_mode == 0 (= compute h(q,qd,gravity)).\nModia3D_1 computeKinematics! Time to compute position, velocity, acceleration with qdd=0.\nModia3D_1 selectContactPairsWithEvent! Time to call selectContactPairsWithEvent! (collision handling).\nModia3D_1 selectContactPairsNoEvent! Time to call selectContactPairsNoEvent! (collision handling).\nModia3D_1 getDistances! Time to call getDistances! (collision handling).\nModia3D_1 dealWithContacts! Time to call dealWithContacts! (collision handling).\nModia3D_1 computeForcesAndResiduals Time to compute forces/torques/residuals (without collision).\nModia3D_2 Time of leq_mode > 0 (= compute M(q)*qdd, for unit vectors of qdd).\nModia3D_2 computeKinematics! Time to compute accelerations with qdd = unit vector.\nModia3D_2 computeForcesAndResiduals Time to compute forces/torques/residuals for M(q)*qdd.\nModia3D_3 Time of leq_mode == -1.\nModia3D_3 visualize! Time of for obj in updateVisuElements ... visualize(..).\nModia3D_3 exportAnimation Time of for obj in allVisuElements ... push!(objectData, dat)\nModia3D_4 isTerminal Time of exportAnimation and closeVisualization during termination.","category":"page"},{"location":"internal/Profiling.html#How-to-instrument-with-@timeit","page":"Profiling","title":"How to instrument with @timeit","text":"","category":"section"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"Further functions in Modia3D can be instrumented in the following way:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"The timer of TimerOutputs is available as instantiatedModel.timer. Therefore, instrumenting a function call is done with:","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"TimerOutputs.@timeit instantiatedModel.timer \"Modia3D XXX\" functionCall(...)","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"or","category":"page"},{"location":"internal/Profiling.html","page":"Profiling","title":"Profiling","text":"TimerOutputs.@timeit instantiatedModel.timer \"Modia3D XXX\" begin\r\n   statements\r\nend","category":"page"},{"location":"Components/Shapes.html#Shapes","page":"Shapes","title":"Shapes","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"CurrentModule = Modia3D.Shapes","category":"page"},{"location":"Components/Shapes.html#––-For-Solid-and-Visual-––","page":"Shapes","title":"–– For Solid and Visual ––","text":"","category":"section"},{"location":"Components/Shapes.html#Sphere","page":"Shapes","title":"Sphere","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Sphere)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Sphere","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Sphere","page":"Shapes","title":"Modia3D.Shapes.Sphere","text":"Sphere(; diameter=1.0)\n\nGenerate a new solid or visual shape representing a sphere. The reference frame = Object3D frame is located at the center of the sphere.\n\nArguments\n\ndiameter defines the diameter of the sphere.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Ellipsoid","page":"Shapes","title":"Ellipsoid","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Ellipsoid)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Ellipsoid","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Ellipsoid","page":"Shapes","title":"Modia3D.Shapes.Ellipsoid","text":"Ellipsoid(; lengthX=1.0, lengthY=1.0, lengthZ=1.0)\n\nGenerate a new solid or visual shape representing an ellipsoid. The reference frame = Object3D frame is located at the center of the ellipsoid.\n\nArguments\n\nlengthX defines the length of the ellipsoid in x-direction.\nlengthY defines the length of the ellipsoid in y-direction.\nlengthZ defines the length of the ellipsoid in z-direction.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Box","page":"Shapes","title":"Box","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Box)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Box","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Box","page":"Shapes","title":"Modia3D.Shapes.Box","text":"Box(; lengthX=1.0, lengthY=1.0, lengthZ=1.0)\n\nGenerate a new solid or visual shape representing a box. The reference frame = Object3D frame is located at the center of the box.\n\nArguments\n\nlengthX defines the length of the box in x-direction.\nlengthY defines the length of the box in y-direction.\nlengthZ defines the length of the box in z-direction.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Cylinder","page":"Shapes","title":"Cylinder","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Cylinder)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Cylinder","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Cylinder","page":"Shapes","title":"Modia3D.Shapes.Cylinder","text":"Cylinder(; axis=3, diameter=1.0, length=1.0, innerDiameter=0.0)\n\nGenerate a new solid or visual shape representing a cylinder. The reference frame = Object3D frame is located at the center of the cylinder.\n\nArguments\n\naxis defines the rotation axis of the cylinder: 1=x; 2=y; 3=z.\ndiameter defines the diameter of the cylinder.\nlength defines the length of the cylinder.\ninnerDiameter defines the inner diameter of the cylinder (where innerDiameter=0 defines a full cylinder).\n\nNotes\n\ninnerDiameter is not supported by collision.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Cone","page":"Shapes","title":"Cone","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Cone)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Cone","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Cone","page":"Shapes","title":"Modia3D.Shapes.Cone","text":"Cone(; axis=3, diameter=1.0, length=1.0, topDiameter=0.0)\n\nGenerate a new solid or visual shape representing a circular cone or a frustum of a circular cone. The reference frame = Object3D frame is located at the center of the base circle of the cone/frustum.\n\nArguments\n\naxis defines the rotation axis of the cone/frustum: 1=x; 2=y; 3=z.\ndiameter defines the diameter of the base circle of the cone/frustum.\nlength defines the length of the cone/frustum.\ntopDiameter defines the diameter of the top circle of the frustum (where topDiameter=0 defines a right cone).\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Capsule","page":"Shapes","title":"Capsule","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Capsule)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Capsule","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Capsule","page":"Shapes","title":"Modia3D.Shapes.Capsule","text":"Capsule(; axis=3, diameter=1.0, length=1.0)\n\nGenerate a new solid or visual shape representing a capsule assembled by a cylinder and two half spheres. The reference frame = Object3D frame is located at the center of the capsule.\n\nArguments\n\naxis defines the rotation axis of the capsule: 1=x; 2=y; 3=z.\ndiameter defines the diameter of the capsule.\nlength defines the length of the middle cylindrical part of the capsule.\n\nNotes\n\nSome versions of SimVis visualize half ellipsoids with semi-axis length length/2 instead of spheres with diameter diameter.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Beam","page":"Shapes","title":"Beam","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Beam)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Beam","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Beam","page":"Shapes","title":"Modia3D.Shapes.Beam","text":"Beam(; axis=3, length=1.0, width=0.2, thickness=0.1)\n\nGenerate a new solid or visual shape representing a beam assembled by a box and two half cylinders. The reference frame = Object3D frame is located at the center of the beam.\n\nArguments\n\naxis defines the longitudinal axis of the beam: 1=x; 2=y; 3=z.\nlength defines the box length of the beam. The total length of the beam is length + width.\nwidth defines the width (= cylinder diameter) of the beam.\nthickness defines the thickness of the beam.\n\nThe dimension directions depend on axis by circularly shift:\n\naxis length width thickness\n1 x y z\n2 y z x\n3 z x y\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#FileMesh","page":"Shapes","title":"FileMesh","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: FileMesh)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"FileMesh","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.FileMesh","page":"Shapes","title":"Modia3D.Shapes.FileMesh","text":"FileMesh(; filename::AbstractString=\"\", scale=SVector{3,Float64}(1.0,1.0,1.0),\nuseMaterialColor::Bool=false, smoothNormals::Bool=false, convexPartition::Bool=false)\n\nGenerate a new solid or visual shape representing a mesh. The reference frame = Object3D frame is defined by the mesh data.\n\nArguments\n\nfilename defines the name of the mesh file.\nscale defines the scaling factors to be applied in x-, y- and z-direction.\nuseMaterialColor defines if the material color of the shape is to be considered.\nsmoothNormals defines if smoothing of mesh normals is active.\nconvexPartition defines if partitioning into convex sub meshes is active.\n\nNotes\n\nSolid features are supported for MeshIO.jl file formats including obj and stl.\nVisual features are supported for SimVis file formats 3ds, dxf, obj and stl.\nFileMesh is not directly supported by animation export. You have to convert your mesh file into the three.js json object scene format first and store it in the same folder as your mesh file.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#––-Only-for-Visual-––","page":"Shapes","title":"–– Only for Visual ––","text":"","category":"section"},{"location":"Components/Shapes.html#CoordinateSystem","page":"Shapes","title":"CoordinateSystem","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: CoordinateSystem)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"CoordinateSystem","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.CoordinateSystem","page":"Shapes","title":"Modia3D.Shapes.CoordinateSystem","text":"CoordinateSystem(; length=1.0)\n\nGenerate a new visual shape representing a coordinate system. The reference frame = Object3D frame coincides with the coordinate system.\n\nArguments\n\nlength defines the length of the coordinate system axes.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Grid","page":"Shapes","title":"Grid","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Grid)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Grid","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Grid","page":"Shapes","title":"Modia3D.Shapes.Grid","text":"Grid(; axis=3, length=1.0, width=0.6, distance=0.1, lineWidth=1.0)\n\nGenerate a new visual shape representing a planar grid. The reference frame = Object3D frame is located at the center of the grid.\n\nArguments\n\naxis defines the normal axis of the grid: 1=x; 2=y; 3=z.\nlength defines the length of the grid.\nwidth defines the width of the grid.\ndistance defines the distance of the grid lines.\nlineWidth defines the line width of the grid.\n\nThe dimension directions depend on axis by circularly shift:\n\naxis length width\n1 y z\n2 z x\n3 x y\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Spring","page":"Shapes","title":"Spring","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: Spring)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"Spring","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.Spring","page":"Shapes","title":"Modia3D.Shapes.Spring","text":"Spring(; axis=3, length=1.0, diameter=1.0, wireDiameter=0.05, windings=5)\n\nGenerate a new visual shape representing a helical spiral spring. The reference frame = Object3D frame is located at the center of the base circle of the spring.\n\nArguments\n\naxis defines the axis of the spring: 1=x; 2=y; 3=z.\nlength defines the length of the spring.\ndiameter defines the diameter of the spring.\nwireDiameter defines the diameter of the spring wire.\nwindings defines the number of windings of the spring.\n\nNotes\n\nSimVis visualizes whole-numbered values of windings.\nSpring is not supported by animation export.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#GearWheel","page":"Shapes","title":"GearWheel","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: GearWheel)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"GearWheel","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.GearWheel","page":"Shapes","title":"Modia3D.Shapes.GearWheel","text":"GearWheel(; axis=3, diameter=1.0, length=1.0, innerDiameter=0.0, angle=0.0, teeth=20)\n\nGenerate a new visual shape representing a gearwheel. The reference frame = Object3D frame is located at the center of the gearwheel.\n\nArguments\n\naxis defines the rotation axis of the gearwheel: 1=x; 2=y; 3=z.\ndiameter defines the diameter of the gearwheel.\nlength defines the length of the gearwheel.\ninnerDiameter defines the inner diameter of the gearwheel (where innerDiameter=0 defines a full gearwheel).\nangle defines the bevel angle of the gearwheel (where angle=0 defines a cylindrical gearwheel).\nteeth defines the number of teeth of the gearwheel.\n\nNotes\n\nGearWheel is not supported by animation export.\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#TextShape","page":"Shapes","title":"TextShape","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"(Image: TextShape)","category":"page"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"TextShape\r\nFont","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.TextShape","page":"Shapes","title":"Modia3D.Shapes.TextShape","text":"TextShape(; text=\"Hello world\", font=Font(), offset=[0.0,0.0,0.0],\n            axisAlignment=Screen, alignment=Center)\n\nGenerate a new visual shape representing a text shape.\n\nArguments\n\ntext::AbstractString: String of the text\nfont::Font: Font of the text\noffset: a 3D vector as offset from origin to text alignment point\naxisAlignment::Modia3D.AxisAlignment: alignment of text\nModia3D.Screen: parallel to screen\nModia3D.XY_Plane: in xy-planes of Object3D\nModia3D.XZ_Plane: in xz-planes of Object3D\nModia3D.YZ_Plane: in yz-planes of Object3D\naxisAlignment::Modia3D.Alignment: defines the direction the text is displayed, relative to its origin\nModia3D.Left, Modia3D.Right or Modia3D.Center\n\nNotes\n\nTextShape is not supported by the community edition of SimVis.\nTextShape is not supported by animation export.\n\nExamples\n\nimport Modia3D\nfont  = Font(fontFamily=\"Arial\", charSize=0.4, color=\"MediumVioletRed\")\ntext1 = TextShape(\"This is a box\")\ntext2 = TextShape(\"This is the xy plane\";\n                   font = font, axisAlignment=Modia3D.XY_Plane,\n                   alignment = Modia3D.Left)\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#Modia3D.Shapes.Font","page":"Shapes","title":"Modia3D.Shapes.Font","text":"Font(; fontFamily=\"FreeSans\", bold=false, italic=false,\n       charSize=0.1, color=defaultColor(), transparency=0.0)\n\nGenerate a Font.\n\nArguments\n\nfontFamily: name of the font family\n\"FreeSans\", \"FreeSerif\", \"Arial\", \"ArialNarrow\", \"CourierNew\", \"TimesNewRoman\", or \"Verdana\"\n\n(Image: fontFamily) Courtesy to DLR Visualization Library\n\nbold: if true, the text is displayed in bold font.\nitalic: if true, the text is displayed in italic font.\ncharSize: character size in [m].\ncolor defines the material color as a String or RGB values. In case of Strings the color         is constructed using Colors.jl. So         named colors and         many other kinds of color specifications         are available. In addition, colors can be directly defined by a vector of RGB values.         E.g. color=\"MediumVioletRed\" or color=[255, 0, 0].\ntransparency: transparency of the fon , 0.0 (opaque) ... 1.0 (transparent)\n\nNotes\n\nfontFamily like \"Arial\", \"Verdana\" are only supported under Windows.\n\nExamples\n\nimport Modia3D\nfont1 = Font()\nfont2 = Font(fontFamily=\"Arial\", bold=true, charSize=0.2,\n             color=\"LightBlue\", transparency=0.5)\n\n\n\n\n\n","category":"type"},{"location":"Components/Shapes.html#ModelicaShape","page":"Shapes","title":"ModelicaShape","text":"","category":"section"},{"location":"Components/Shapes.html","page":"Shapes","title":"Shapes","text":"ModelicaShape","category":"page"},{"location":"Components/Shapes.html#Modia3D.Shapes.ModelicaShape","page":"Shapes","title":"Modia3D.Shapes.ModelicaShape","text":"ModelicaShape(; type=1, lengthX=1.0, lengthY=1.0, lengthZ=1.0, extra=[0.0, 0.0, 0.0])\n\nGenerate a new visual shape according to the Modelica Visualization Library.\n\nArguments\n\ntype defines the type of the shape: 1=box; 2=sphere; 3=cylinder; 4=cone; 5=capsule; 6=coordinate system; 7=spring; 8=gearwheel; 9=pipe; 10=grid; 11=beam.\nlengthX defines the length of the shape in x-direction.\nlengthY defines the length of the shape in y-direction.\nlengthZ defines the length of the shape in z-direction.\nextra defines extra parameters for cone, pipe, spring and gearwheel.\n\nNotes\n\nModelicaShape is intended for import of Modelica models and not for Modia3D models.\nModelicaShape is not supported by animation export.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/HierarchicalModels.html#Hierarchical-models","page":"Hierarchical models","title":"Hierarchical models","text":"","category":"section"},{"location":"tutorial/HierarchicalModels.html","page":"Hierarchical models","title":"Hierarchical models","text":"TO DO: Model hierarchical systems (Pendulum with bar & controller with path planning)","category":"page"},{"location":"tutorial/CollisionHandling.html#Collision-Handling","page":"Collision Handling","title":"Collision Handling","text":"","category":"section"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Collision handling with elastic response calculation is performed for convex shapes that are defined with a contact material or solid material. The elastic response calculation is currently solely based on the information about the largest penetration that is computed with an improved Minkowski Portal Refinement (MPR) algorithm. Collision response with an adaptive integration method works only reasonable, if the convex objects have point-contact.","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Collision handling can be globally activated with keyword enableContactDetection = true set in the Scene. Only Solid Object3Ds can take place in collision situations.","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"The example in \"$(Modia3D.path)/test/Tutorial/BouncingSphere.jl\" defines a sphere that is bouncing on the ground. The essential statements are:","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"module BouncingSphere3D\r\n\r\nusing Modia3D\r\n\r\nBouncingSphere = Model3D(\r\n    boxHeigth = 0.1,\r\n    world      = Object3D(feature=Scene(enableContactDetection = true,\r\n                    animationFile = \"BouncingSphere.json\")),\r\n    ground     = Object3D(parent=:world, translation=:[0.0,-boxHeigth/2,0.0],\r\n                    feature=Solid(shape=Box(lengthX=4.0, lengthY=:boxHeigth, lengthZ=0.7),\r\n                        visualMaterial=VisualMaterial(color=\"DarkGreen\"),\r\n                        solidMaterial=\"Steel\",\r\n                        collision=true)),\r\n    sphere     = Object3D(feature=Solid(shape=Sphere(diameter=0.2),\r\n                        visualMaterial=VisualMaterial(color=\"Blue\"),\r\n                        solidMaterial=\"Steel\",\r\n                        massProperties=MassPropertiesFromShapeAndMass(mass=0.001),\r\n                        collision=true)),\r\n    free       = FreeMotion(obj1=:world, obj2=:sphere, r=Var(init=[0.0, 1.0, 0.0]))\r\n)\r\n\r\nbouncingSphere = @instantiateModel(BouncingSphere, unitless=true)\r\nsimulate!(bouncingSphere, stopTime=2.2, dtmax=0.1)\r\n\r\n@usingModiaPlot\r\nplot(bouncingSphere, \"free.r\", figure=1)\r\n\r\nend","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"or","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"julia> import Modia3D\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/BouncingSphere.jl\")","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"The commands above generate an instance of the model, simulate it and generate the following plot:","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"(Image: Tutorial-Collision)","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Note:","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Only Solid Object3Ds where a shape is defined and collision=true is considered in collision handling.","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Supported Shapes are: Sphere, Ellipsoid, Box, Cylinder, Cone, Capsule, Beam, FileMesh.\nFileMesh:\nOnly .obj files are supported.\nMPR algorithm uses the convex hull of a concave geometry, or you have to partition it into convex sub meshes with e.g., V-HACD.","category":"page"},{"location":"tutorial/CollisionHandling.html","page":"Collision Handling","title":"Collision Handling","text":"Make sure mass properties are computed and define how it behaves in contact situations. Define a solidMaterial=\"NameOfSolidMaterial\" or a contactMaterial=\"NameOfContactMaterial\" (this defines for example YoungsModulus). The used names must be available in the Modia3D/palettes/contactPairMaterials.json where for various combinations of contact materials, additional data is provided (for example the coefficientOfRestitution). For more details about the contact material data, see Solid material and Contact pair material. The details of the contact computation are sketched in Contact Force Law.","category":"page"},{"location":"internal/ContactDetection.html#Contact-Detection","page":"Contact Detection","title":"Contact Detection","text":"","category":"section"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"This section is based on [1] with some minor improvements.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"The following goals shall be achieved:","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Whenever two objects start to penetrate, an event shall be triggered in order that integration methods with step-size control are simulating efficiencly (at the start of the contact, contact forces and torques with non-zero values are typically introduced leading to strong discontinuous changes of the equations).\nWhen two objects start to penetrate, the normal contact velocity dotdelta^- needs to be stored, because used in the contact force law.\nWhenever two penetrating objects are not penetrating any more, again an event shall be triggered.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Modia3D uses DifferentialEquations.jl integrators to solve the equations. These integrators trigger an event when a zero crossing function crosses zero. Hereby, the option DifferentialEquations.SciMLBase.RightRootFind is used, that is, an event is triggered when the zero crossing function is either identical to zero or has an opposite sign. At an event restart it is required that the zero crossing functions are not identical to zero, since otherwise a zero crossing cannot be detected.","category":"page"},{"location":"internal/ContactDetection.html#Zero-crossing-functions","page":"Contact Detection","title":"Zero crossing functions","text":"","category":"section"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"The distance between two objects computed either in the narrow phase or in an approximate way in the broad phase (= distance between Axis Aligned Bounding Boxes) is called distanceOrg. If distanceOrg < 0, then the two objects are penetrating each other.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Modia3D uses the dictionary contactDict to keep track of the contact situation. Every pair of objects is identified by a unique Integer value called PairID that is used as key in conctactDict. A dictionary value is an instance of Modia3D.ContactPair","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"At an event instant (including initialization), dictionary contactDict is emptied and all object pairs are stored newly in contactDict that have distanceOrg <= 0, so are either touching or penetrating.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"During continuous integration, two zero crossing functions are used:","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"z_1(t): The maximum of distanceOrg - 10^-16 of all object pairs that are in contactDict. z_1 monitors if an object pair that has been in contact, looses contact. Since distanceOrg values in contactDict are in the order of 10^-3  10^-6 m and eps(Float64) approx 10^-16, a hysteresis epsilon must be larger as 10^-19  10^-24. Actually, a hysteresis epsilon of 10^-16 is used. Note, that in contactDict all distanceOrg values are zero or negative at event restart. It is therefore guaranteed that z_1 le - 10^-16 at event restart (when no contact pair is present, a dummy value is used).","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"z_2(t): The minimum distanceOrg of all object pairs that are not in contactDict. z_2 monitors if two objects that have not been in contact to each other and start to penetrate each other. At an event restart (including the start of the integration after the initialization), it is guaranteed that all distanceOrg not in contactDict are positive (otherwise, they would be in contactDict). Therefore, it is guaranteed that z_2  0 at event restart (without a hysteresis epsilon).","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"The distance between two objects is only computed up to a certain precision. Therefore, distanceOrg might be nearly zero but still positive, if two objects are placed initially in touching position. For this reason the actually used distance is distanceOrg - 1e-16, in order that the probability is larger that objects initially in touching position are treated to be in contact initially.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"To summarize, the following equations are actually used:","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"distance = distanceOrg - 1e-16\r\ncontact  = isEvent ? distance <= 0 : <contact from previous event>\r\nz[1]     = max(<distance that has contact=true>) - 1e-16\r\nz[2]     = min(<distance that has contact=false>)","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Typically, the simulate!(..., log=true, ...) produces the following output (here for a sphere boucing on ground):","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":" State event (zero-crossing) at time = 2.3924142776549155 s (due to z[2])\r\n   distance(ground,sphere) = -3.815173674537923e-18 became <= 0\r\n       contact normal = [0.0, 1.0, 0.0], contact position = [0.0, -0.1, 0.0], c_res = 1.1e11 d_res = 47.5\r\n   restart = Restart\r\n\r\nState event (zero-crossing) at time = 2.3924413895015424 s (due to z[1])\r\n   distance(ground,sphere) = 1.0362163563391329e-16 became > 0\r\n   restart = Restart","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Whenever the integrator requires the values of the zero crossing functions, the values of z_1 z_2 are newly computed. At all other time instants (e.g. communication points), only the distances of the object pairs are computed that are in dictionary contactDict, because these distances are used to compute the contact forces and torques. Distances of object pairs that are not in contact to each other are not computed at these time instants.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Whenever contact starts newly for an object pair, the normal contact velocity dotdelta^- needs to be stored, since needed from the elastic response calculation. When a contact pair was already in contact at an event, it is necessary to utilize dotdelta^- from the previous event also at the actual event. In order that these two requirements are fulfilled, a second dictionary lastContactDict is used: Once contactDict is constructed at an event, a copy is stored in lastContactDict. At the next event, a new contactDict is constructed. Whenever an object pair is included in contactDict that is also present in lastContactDict, then the normal contact velocity dotdelta^- stored in lastContactDict is utilized.","category":"page"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Note, in scene.options.contactDetection (file Modia3D/src/contactDetection/ContactDectionMPR_handler.jl) information about the contact situation is stored in an instance of Modia3D.ContactDetectionMPR_handler.","category":"page"},{"location":"internal/ContactDetection.html#Collision-handling-types","page":"Contact Detection","title":"Collision handling types","text":"","category":"section"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Modia3D.ContactPair","category":"page"},{"location":"internal/ContactDetection.html#Modia3D.Composition.ContactPair","page":"Contact Detection","title":"Modia3D.Composition.ContactPair","text":"ContactPair(contactPointA, contactPointB,\n    contactNormal, objA, objB,\n    distanceWithHysteresis, supportPointsDefined,\n    support1A, support2A, support3A,\n    support1B, support2B, support3B)\n\nGenerate a new ContactPair object of two objects that have contact = true.\n\n\n\n\n\n","category":"type"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"Modia3D.ContactDetectionMPR_handler","category":"page"},{"location":"internal/ContactDetection.html#Modia3D.Composition.ContactDetectionMPR_handler","page":"Contact Detection","title":"Modia3D.Composition.ContactDetectionMPR_handler","text":"handler = ContactDetectionMPR_handler(;tol_rel = 1e-7, niter_max=100)\n\nGenerate a new contact handler for usage of the MPR algorithm The handler instance contains all information about the contact situation.\n\nArguments\n\ntol_rel: Relative tolerance to compute the contact point (> 0.0)\nniter_max: Maximum number of iterations of the MPR algorithm. If this number is reached,              an error occurs (> 0).\n\n\n\n\n\n","category":"type"},{"location":"internal/ContactDetection.html#Literature","page":"Contact Detection","title":"Literature","text":"","category":"section"},{"location":"internal/ContactDetection.html","page":"Contact Detection","title":"Contact Detection","text":"[1]: Andrea Neumayr, Martin Otter (2019):   Collision Handling with Elastic Response Calculation and Zero-Crossing Functions.   Proceedings of the 9th International Workshop on Equation-Based Object-Oriented Modeling Languages and Tools. EOOLT’19. ACM, pp. 57–65.","category":"page"},{"location":"Components/ForceElements.html#Force-Elements","page":"Force Elements","title":"Force Elements","text":"","category":"section"},{"location":"Components/ForceElements.html","page":"Force Elements","title":"Force Elements","text":"CurrentModule = Modia3D.Composition","category":"page"},{"location":"Components/ForceElements.html#Bushing","page":"Force Elements","title":"Bushing","text":"","category":"section"},{"location":"Components/ForceElements.html","page":"Force Elements","title":"Force Elements","text":"Bushing","category":"page"},{"location":"Components/ForceElements.html#Modia3D.Composition.Bushing","page":"Force Elements","title":"Modia3D.Composition.Bushing","text":"force = Bushing(; obj1, obj2,\n    nominalForce      = [0.0, 0.0, 0.0],\n    springForceLaw    = [0.0, 0.0, 0.0],\n    damperForceLaw    = [0.0, 0.0, 0.0],\n    nominalTorque     = [0.0, 0.0, 0.0],\n    rotSpringForceLaw = [0.0, 0.0, 0.0],\n    rotDamperForceLaw = [0.0, 0.0, 0.0],\n    largeAngles       = false )\n\nReturn a force acting as bushing between obj1::Object3D and obj2::Object3D. The force directions are defined by obj1, i.e. the orientation of obj2 does not influence the resulting forces.\n\nArguments\n\nnominalForce defines the nominal force vector, i.e. the force that acts when spring and damper forces are zero. Positive values act in positive axis directions at obj1 and in opposite directions at obj2.\nspringForceLaw defines the force law of the spring in x-, y- and z-direction:\nA Real number represents a linear stiffness coefficient.\nAn univariate Function is used to compute the spring force dependent of its deflection.\ndamperForceLaw defines the force law of the damper in x-, y- and z-direction:\nA Real number represents a linear damping coefficient.\nAn univariate Function is used to compute the damper force dependent of its deflection velocity.\nnominalTorque defines nominal torques about alpha, beta and gamma directions.\nrotSpringForceLaw defines the force law of the rotational spring about alpha-, beta- and gamma-direction:\nA Real number represents a linear damping coefficient.\nAn univariate Function is used to compute the spring force dependent of its deflection.\nrotDamperForceLaw defines the force law of the rotational damper about alpha-, beta- and gamma-direction:\nA Real number represents a linear damping coefficient.\nAn univariate Function is used to compute the damper force dependent of its deflection velocity.\nlargeAngles can be used to enable large angle mode.\nWhen disabled, small deformation angles (< 10°) are assumed. This option deals equally with rotations [alpha, beta gamma] about the axes [x, y, z] of obj1, but causes approximation errors for larger angles.\nWhen enabled, the deformation angles and torque directions are calculated as Cardan (Tait–Bryan) angles (rotation sequence x-y-z from obj1 to obj2). This option supports angles up to nearly 90°, but introduces local rotation directions [alpha, beta gamma] which differ from the axes [x, y, z] of obj1 and increases computation effort.\n\n\n\n\n\n","category":"type"},{"location":"Components/ForceElements.html#SpringDamperPtP","page":"Force Elements","title":"SpringDamperPtP","text":"","category":"section"},{"location":"Components/ForceElements.html","page":"Force Elements","title":"Force Elements","text":"SpringDamperPtP","category":"page"},{"location":"Components/ForceElements.html#Modia3D.Composition.SpringDamperPtP","page":"Force Elements","title":"Modia3D.Composition.SpringDamperPtP","text":"force = SpringDamperPtP(; obj1, obj2,\n    nominalLength  = 0.0,\n    nominalForce   = 0.0,\n    springForceLaw = 0.0,\n    damperForceLaw = 0.0 )\n\nReturn a force acting as point-to-point parallel spring-damper between obj1::Object3D and obj2::Object3D.\n\nArguments\n\nnominalLength defines the nominal length, i.e. the distance between obj1 and obj2 where the deflection of the spring is zero.\nnominalForce defines the nominal force, i.e. the force that acts when spring and damper forces are zero. Positive values represent tension.\nspringForceLaw defines the force law of the spring:\nA Real number represents a linear stiffness coefficient.\nAn univariate Function is used to compute the spring force dependent of its deflection. Positive values represent tension.\ndamperForceLaw defines the force law of the damper:\nA Real number represents a linear damping coefficient.\nAn univariate Function is used to compute the damper force dependent of its deflection velocity. Positive values represent expansion.\n\n\n\n\n\n","category":"type"},{"location":"tutorial/GettingStarted.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"An Object3D constructor is the core element of Modia3D. It defines a coordinate system moving in 3D together with associated features like Scene, Visual and Solid:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: Object3D)","category":"page"},{"location":"tutorial/GettingStarted.html#.-Pendulum","page":"Getting Started","title":"1. Pendulum","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"In the following example a simple pendulum is defined. This example is a copy of: $(Modia3D.path)/test/Tutorial/Pendulum1.jl. Here is a short description of how to execute a Julia file in VS Code,","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"module Pendulum1\r\n\r\nusing Modia3D\r\n\r\nPendulum = Model3D(\r\n    world     = Object3D(feature=Scene()),\r\n    body      = Object3D(feature=Solid(massProperties=MassProperties(mass=1.0))),\r\n    bodyFrame = Object3D(parent=:body, translation=[-0.5, 0.0, 0.0]),\r\n    rev       = Revolute(obj1=:world, obj2=:bodyFrame)\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum, unitless=true)\r\nsimulate!(pendulum, stopTime=3.0)\r\n\r\n@usingModiaPlot     # use the plot package defined by ENV[\"MODIA_PLOT\"]\r\nplot(pendulum, \"rev.phi\")\r\n\r\nend","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"or execute it in the Julia REPL","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> import Modia3D  # is only required for '$(Modia3D.path)' in the include command\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum1.jl\")","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The world Object3D has feature Scene and is therefore the inertial system. The body Object3D is a Solid and defines the pendulum as a mass point with mass = 1.0. The bodyFrame Object3D defines a coordinate system on the body that is translated along the x-axis. A revolute joint connects world with bodyFrame.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"With command Model3D(..), a few lines of code are included, in order that joint variables are communicated between the Modia equations and the Modia3D multibody program. Keyword unitless=true defines that code generation is performed without units (because Modia3D does not yet fully support units in all components).","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The commands above generate an instance of the model, simulate it and generate the following plot:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: Tutorial-Pendulum1)","category":"page"},{"location":"tutorial/GettingStarted.html#.-Pendulum-with-Animation","page":"Getting Started","title":"2. Pendulum with Animation","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The Object3Ds of the first example are extended with Visual and Solid features in order that the pendulum parts are visualized and exported for offline animation by defining animationFile = \"Pendulum2.json\" in Scene. The first Object3D obj1 is defined as a solid Beam with \"Blue\"color and its Solid material is made of \"Steel\". Mass, center of mass and inertia tensor are computed from Steel density and from the Beam shape. The second Object3D obj2 is a visual red Cylinder that is used to visualize the axis of the revolute joint. Please, see example: $(Modia3D.path)/test/Tutorial/Pendulum2.jl","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"module Pendulum2\r\n\r\nusing Modia3D\r\n\r\nPendulum = Model3D(\r\n    world = Object3D(feature=Scene(animationFile=\"Pendulum2.json\")),\r\n    obj1  = Object3D(feature=Solid(shape=Beam(axis=1, length=1.0, width=0.2, thickness=0.2),\r\n                solidMaterial=\"Steel\", visualMaterial=VisualMaterial(color=\"Blue\"))),\r\n    obj2  = Object3D(parent=:obj1, feature=Visual(shape=Cylinder(diameter=0.1, length=0.21),\r\n                visualMaterial=VisualMaterial(color=\"Red\")), translation=[-0.5, 0.0, 0.0]),\r\n    rev   = Revolute(obj1=:world, obj2=:obj2)\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum, unitless=true)\r\nsimulate!(pendulum, stopTime=3.0)\r\n\r\n@usingModiaPlot\r\nplot(pendulum, \"rev.phi\")\r\n\r\nend","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"or","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> import Modia3D\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum2.jl\")","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"Open the three.js editor, import (File –> Import) the json file Pendulum2.json in your working directory and inspect the model:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: Tutorial-Pendulum2)","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"View the simulation animation by clicking the Play button in the Object tab.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"Export the animation in glb format (File –> Export GLB) to view it in a glb/glTF viewer (for example the 3D-Viewer of Windows 10).","category":"page"},{"location":"tutorial/GettingStarted.html#.-Pendulum-with-Modia-equations","page":"Getting Started","title":"3. Pendulum with Modia equations","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The pendulum model from the previous section is extended with a damper that is defined with Modia language components and models the damping (sliding friction) in the revolute joint. In order that this is possible, a RevoluteWithFlange joints has to be used that provides a Flange connector to which a rotational 1-dim. Flange of Modia can be connected. This flange and the Damper, and the Fixed component are defined in a small Modia model library that is included viainclude(\"$(Modia.path)/models/AllModels.jl\"). Please, see example: $(Modia3D.path)/test/Tutorial/Pendulum3.jl","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"module Pendulum3\r\n\r\nusing Modia3D\r\n\r\ninclude(\"$(Modia3D.modelsPath)/AllModels.jl\")\r\n\r\nPendulum = Model3D(\r\n    world = Object3D(feature=Scene(animationFile=\"Pendulum3.json\")),\r\n    obj1  = Object3D(feature=Solid(shape=Beam(axis=1, length=1.0, width=0.2, thickness=0.2),\r\n                solidMaterial=\"Steel\", visualMaterial=VisualMaterial(color=\"Blue\"))),\r\n    obj2  = Object3D(parent=:obj1, feature=Visual(shape=Cylinder(diameter=0.1, length=0.21),\r\n                visualMaterial=VisualMaterial(color=\"Red\")), translation=[-0.5, 0.0, 0.0]),\r\n    rev   = RevoluteWithFlange(obj1=:world, obj2=:obj2),\r\n\r\n    damper  = Damper | Map(d=100.0),\r\n    fixed   = Fixed,\r\n    connect = :[(damper.flange_b, rev.flange),\r\n                (damper.flange_a, fixed.flange)]\r\n)\r\n\r\npendulum = @instantiateModel(Pendulum, unitless=true)\r\nsimulate!(pendulum, stopTime=3.0)\r\n\r\n@usingModiaPlot\r\nplot(pendulum, \"rev.phi\")\r\n\r\nend","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"or","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> import Modia3D\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum3.jl\")","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"The commands above generate an instance of the model, simulate it and generate the following plot:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"(Image: Tutorial-Pendulum3)","category":"page"},{"location":"tutorial/GettingStarted.html#.-Example-and-Test-Models","page":"Getting Started","title":"4. Example and Test Models","text":"","category":"section"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"All examples of this tutorial are stored in $(Modia3D.path)/test/Tutorial.","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> import Modia3D\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum1.jl\")\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum2.jl\")\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/Pendulum3.jl\")\r\njulia> include(\"$(Modia3D.path)/test/Tutorial/BouncingSphere.jl\")","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To run all tests without graphics, execute:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> include(\"$(Modia3D.path)/test/runtests.jl\")","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"To run all tests with visualization and plots, execute:","category":"page"},{"location":"tutorial/GettingStarted.html","page":"Getting Started","title":"Getting Started","text":"julia> include(\"$(Modia3D.path)/test/runtestsWithGraphics.jl\")","category":"page"},{"location":"tutorial/RecursiveModels.html#Recursive-models","page":"Recursive models","title":"Recursive models","text":"","category":"section"},{"location":"tutorial/RecursiveModels.html","page":"Recursive models","title":"Recursive models","text":"TO DO: Define models recursively - show with Mobile","category":"page"},{"location":"Components/Materials.html#Materials","page":"Materials","title":"Materials","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Modia3D uses various materials for different kind of purposes. In this section an overview of the material data and material palettes is given, as well as links to more detailed information. The following materia data is supported","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Visual material: Visualization properties of a geometrical object, such as color or transparency.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Solid material: Material constants of one solid, such as density or Young's modulus.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Contact pair material: Material constants that are related to two solids that are in contact to each other, such as the coefficient of restitution between a Steel and an Aluminium object.","category":"page"},{"location":"Components/Materials.html#Visual-material","page":"Materials","title":"Visual material","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"The mutable struct Modia3D.Shapes.VisualMaterial defines various visual properties of a geometrical object, such as color or transparency. This data is used for visualization. Currently, there is no dictionary provided.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Modia3D.Shapes.VisualMaterial","category":"page"},{"location":"Components/Materials.html#Modia3D.Shapes.VisualMaterial","page":"Materials","title":"Modia3D.Shapes.VisualMaterial","text":"VisualMaterial(; color=\"Green\",\n                 wireframe=false, transparency=0.5,\n                 reflectslight=true, shininess=0.7,\n                 shadowMask=CastsAndReceivesShadows))\n\nReturn a material object that defines attributes for the visualization of an Object3D that has visual or solid properties.\n\nArguments\n\ncolor defines the material color as a String or RGB values. In case of Strings the color         is constructed using Colors.jl. So         named colors and         many other kinds of color specifications         are available. In addition, colors can be directly defined by a vector of RGB values.         E.g. color=\"MediumVioletRed\" or color=[255, 0, 0].\nwireframe: = false, if solid, otherwise wireframe representation.\ntransparency: = 0.0 (opaque) ... 1.0 (fully transparent).\nreflectslight: = true if it reflects light and false, if it does not reflect light.\nshininess: = 0.0 (matte surface) ... 1.0 (very shiny surface).\nshadowMask: defines whether or not an object casts or receives shadows. Possible values:  NoShadows, CastsShadows, ReceivesShadows, CastsAndReceivesShadows.\n\n\n\n\n\n","category":"type"},{"location":"Components/Materials.html#Solid-material","page":"Materials","title":"Solid material","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"A Solid material is needed for computing mass properties with inertia (from density and the object's shape) and for Collision Handling (with YoungsModulus and PoissonsRatio). There are predefined solidMaterials in Modia3D/palettes/solidMaterials.json. The material name (a string) is the key for reading and creating a Solid material.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Modia3D.Shapes.SolidMaterial","category":"page"},{"location":"Components/Materials.html#Modia3D.Shapes.SolidMaterial","page":"Materials","title":"Modia3D.Shapes.SolidMaterial","text":"SolidMaterial(density=3000.0, YoungsModulus=2e11)\n\nGenerates a SolidMaterial object by providing the material properties of a [Solid] with keyword arguments.\n\nArguments\n\nArguments that are not provided have value NaN.\n\ndensity in [kg/m^3]: Density, see Wikipedia.\nYoungsModulus in [Pa]: Youngs's modulus, see Wikipedia.\nPoissonsRatio: Poisson's ratio, see Wikipedia.\nmeltingPoint in [K]: Melting point, see Wikipedia.                        If the material is destroyed before its melting point (e.g. wood that is burning)                       then meltingPoint is the temperature when destruction of the solid starts.\nspecificHeatCapacity in [J/(kg.K)]: Specific heat capacity, see Wikipedia.\nthermalConductivity in [W/(m.K)]: Thermal conductivity, see Wikipedia and                               List of thermal conductivities\nlinearThermalExpansionCoefficient::Float64 in [1/K]: Linear thermal expansion coefficient, see Wikipedia.\n\n\n\n\n\n","category":"type"},{"location":"Components/Materials.html#Content-of-solid-material-palette","page":"Materials","title":"Content of solid material palette","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"This is how a solid material is defined in Modia3D/palettes/solidMaterials.json.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"\"Steel\": {\r\n    \"density\": 8000.0,\r\n    \"YoungsModulus\": 2.0e11,\r\n    \"PoissonsRatio\": 0.3,\r\n    \"meltingPoint\": 1640.0,\r\n    \"specificHeatCapacity\": 500.0,\r\n    \"thermalConductivity\": 50.0,\r\n    \"linearThermalExpansionCoefficient\": 1.2e-5\r\n}","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"List of all available keys in Modia3D/palettes/solidMaterials.json. You can add your own solidMaterial to the list.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"import Modia3D\r\nModia3D.listKeys(Modia3D.solidMaterialPalette)","category":"page"},{"location":"Components/Materials.html#Contact-pair-material","page":"Materials","title":"Contact pair material","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"The file Modia3D/palettes/contactPairMaterials.json provides material constants that are related to two solids that are in contact to each other, for example the coefficientOfRestitution between a \"Steel\" and another \"Steel\" object.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"Modia3D.Shapes.ElasticContactPairMaterial","category":"page"},{"location":"Components/Materials.html#Modia3D.Shapes.ElasticContactPairMaterial","page":"Materials","title":"Modia3D.Shapes.ElasticContactPairMaterial","text":"ElasticContactPairMaterial(; coefficientOfRestitution=0.7,\n                             slidingFrictionCoefficient=0.5,\n                             rotationalResistanceCoefficient=0.001,\n                             vsmall=0.01, wsmall=0.01)\n\nGenerates an ElasticContactPairMaterial object by providing the material properties of two objects that are in contact to each other. Those properties are needed for the Contact Force Law.\n\nArguments\n\ncoefficientOfRestitution: Coefficient of restitution between two objects (=0: inelastic ... =1: fully elastic).\nslidingFrictionCoefficient: Kinetic/sliding friction force coefficent between two objects (>= 0.0).\nrotationalResistanceCoefficient: Rotational resistance torque coefficient between two objects (>= 0.0). Its effect is that the contact torque is computed to reduce the relative angular velocity between two objects. For a ball, rotationalResistanceCoefficient is the (standard) rolling resistance coefficient.\nvsmall in [m/s]: Used for regularization when computing the unit vector in direction of the relative tangential velocity to avoid a division by zero.\nwsmall in [rad/s]: Used for regularization when computing the unit vector in direction of the relative angular velocity to avoid a division by zero.\n\n\n\n\n\n","category":"type"},{"location":"Components/Materials.html#Content-of-contact-pairs-palette","page":"Materials","title":"Content of contact pairs palette","text":"","category":"section"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"This is how a contact pair of two \"Steel\" pairing is defined in Modia3D/palettes/contactPairMaterials.json.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"\"Steel,Steel\": {\r\n    \"responseType\": \"ElasticResponse\",\r\n    \"coefficientOfRestitution\": 0.7,\r\n    \"slidingFrictionCoefficient\": 0.5,\r\n    \"rotationalResistanceCoefficient\": 0.001","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"All available contact pairs. You can add your own contact pair material to this palette. It is filled during the first usage of Modia3D from file Modia3D/palettes/contactPairMaterials.json.","category":"page"},{"location":"Components/Materials.html","page":"Materials","title":"Materials","text":"import Modia3D\r\nModia3D.listKeys(Modia3D.contactPairMaterialPalette)","category":"page"},{"location":"internal/DynamicDispatch.html#Dynamic-Dispatch","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"","category":"section"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"Modia3D uses several abstract types in structs in order to store information about different types of joints, shapes, collision response laws etc. Several functions are used to operate on these types. A direct implementation would lead to dynamic dispatch, so the functions to be called and the types to be operated on, would be determined at run-time (and not at compile time). This leads to slow simulation and a lot of memory allocation during simulation.","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"In this forum discussion a similar issue is discussed for a tiny use case and three solutions are compared: (1) dynamic dispatch, (2) dictionary lookup, and (3) if-clauses. In this simple example version (3) is about a factor of 15 faster as (1) and allocates 200 bytes, whereas (1) allocates 1.5 Mbyte.","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"In the rest of this section the technique is sketched that is used in Modia3D to avoid (a) dynamic dispatch and (b) access of abstract types during simulation:","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"The Object3D struct holds all information about an Object3D object:","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"@enum JointKind FixKind RevoluteKind PrismaticKind ...\r\n@enum ShapeKind NoShapeKind SphereKind BoxKind CylinderKind ...\r\n\r\nmutable struct Object3D\r\n    ...\r\n    # Relative motion parent/Object3D\r\n    joint::AbstractJoint               # ::Fix, ::Revolute, ...\r\n\r\n    # Efficient access of joint properties\r\n    jointKind::JointKind               # Kind of joint\r\n    ndof::Int                          # Number of degrees of freedom\r\n    canCollide::Bool                   # = false, if no collision parent/Object3D\r\n\r\n    # Feature associated with Object3D\r\n    feature::AbstractObject3DFeature   # ::EmptyObject3DFeature ::Scene, ::Visual, ::Solid\r\n\r\n    # Efficient access of feature properties\r\n    shapeKind::Shapes.ShapeKind        # Kind of shape\r\n    shape::Modia3D.AbstractShape\r\n    visualMaterial::Shapes.VisualMaterial\r\n    ...\r\nend","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"In particular it holds abstract types for the joint and the feature associated with the Object3D. During initialization, the properties of joint and feature are copied to storage locations that have a concrete type. ","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"All operations on the abstract types are implemented with if-clauses and only access concrete types. For example, Support points needed to determine the shortest distances between colliding Object3D's are computed with:","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"function supportPoint(obj::Object3D, e::SVector{3,Float64})::SVector{3,Float64}\r\n    shapeKind                = obj.shapeKind   # type Int\r\n    solid::Modia3D.Solid     = obj.feature\r\n    collisionSmoothingRadius = solid.collisionSmoothingRadius  # type Float64\r\n\r\n    if shapeKind == Modia3D.SphereKind\r\n        return supportPoint_Sphere(obj.shape, obj.r_abs, obj.R_abs, e)\r\n    elseif shapeKind == Modia3D.EllipsoidKind\r\n        return supportPoint_Ellipsoid(obj.shape, obj.r_abs, obj.R_abs, e)\r\n    elseif shapeKind == Modia3D.BoxKind\r\n        return supportPoint_Box(obj.shape, obj.r_abs, obj.R_abs, e, collisionSmoothingRadius)\r\n    ...\r\n    end\r\nend","category":"page"},{"location":"internal/DynamicDispatch.html","page":"Dynamic Dispatch","title":"Dynamic Dispatch","text":"Note, a function such as supportPoint_Sphere(..) requires that its first argument is an instance of the concrete type Sphere. Due to the if-clause, this is guaranteed. Julia will just make a cheap run-time check that this requirement is fulfilled. The concrete function (supportPoint_Sphere) is translated when llvm code is generated.","category":"page"},{"location":"tutorial/Tutorial.html#Modia3D-Tutorial","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"","category":"section"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"This tutorial sketches the main features of Modia3D with examples. A detailed description is available in Modia3D Components.","category":"page"},{"location":"tutorial/Tutorial.html#Plotting","page":"Modia3D Tutorial","title":"Plotting","text":"","category":"section"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Modia offers an interface to various plot packages. Please, read also the installation guide. Valid options are:","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Environment option Modia package Description\n\"GLMakie\" ModiaPlot_GLMakie interactive plots in an OpenGL window\n\"WGLMakie\" ModiaPlot_WGLMakie interactive plots in a browser window\n\"CairoMakie\" ModiaPlot_CairoMakie static plots on file with publication quality\n\"PyPlot\" ModiaPlot_PyPlot plots with Matplotlib from Python\n\"NoPlot\"  all plot(...) calls are ignored\n\"SilentNoPlot\"  like \"NoPlot\" without messages","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"First, you need to add the corresponding Modia package, e.g.","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"julia> ] add ModiaPlot_GLMakie","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"A plot package can be either selected by setting ENV[\"MODIA_PLOT\"] = \"GLMakie\", in the startup.jl file of Julia or with command Modia.usePlotPackage(\"GLMakie\").","category":"page"},{"location":"tutorial/Tutorial.html#D-Renderer","page":"Modia3D Tutorial","title":"3D Renderer","text":"","category":"section"},{"location":"tutorial/Tutorial.html#Three.js","page":"Modia3D Tutorial","title":"Three.js","text":"","category":"section"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Modia3D animation can be exported in threejs-json-format and then imported in the open source web app threejs.org and use all the features of threejs, for example to export in the widely used glb format (= the binary version of the glTF format) and use any glb-viewer (for example 3D-Viewer of Windows 10).","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Objects are visualized and exported for offline animation by defining animationFile = \"Pendulum2.json\" in Scene, see 2. Pendulum with Animation.","category":"page"},{"location":"tutorial/Tutorial.html#The-DLR-Visualization-Library","page":"Modia3D Tutorial","title":"The DLR Visualization Library","text":"","category":"section"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Modia3D uses the (free) community or the (commercial) professional version of the DLR Visualization Library for 3D simulations. It provides online animation (during simulation) and the generation of mpg4-videos. If you don't use the DLR Visualization Library result animation is switched of. Download and install the free DLR SimVis Community Edition, e.g. with https://visualization.ltx.de/ .","category":"page"},{"location":"tutorial/Tutorial.html","page":"Modia3D Tutorial","title":"Modia3D Tutorial","text":"Set an environment variable or add it to the startup.jl file. Please, read also the installation guide.\nENV[\"DLR_VISUALIZATION\"] = \"<path-to-library>/Visualization/Extras/SimVis\"\nMake sure that the SimVis executable under this directory has execution rights. For example in Linux with command: chmod ug+x <path-to-library>/Visualization/Extras/SimVis/linux/SimVis","category":"page"},{"location":"index.html#Modia3D-Documentation","page":"Home","title":"Modia3D Documentation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia3D is a Julia package that integrates a multibody program and 3D shapes for visualization and collision handling into the Modia Modeling Language. It is then, for example, possible to model the 3D mechanical part of a robot with Modia3D and the electrical motors and gearboxes that are driving the joints with the Modia language. Collision handling with elastic response calculation is performed for shapes that are defined with a contact material and have a convex geometry or are approximated by the convex hull of a concave geometry. For more details, see the Modia3D Tutorial.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"The multibody program supports currently tree-structured multibody systems, but does not (yet) support kinematic loops.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Example videos:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"YouBot robots with gripping\nBilliard table with 16 balls\nMobile with depthmax=8","category":"page"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia3D is included in Modia and is available, when Modia was installed. Please, follow the extensive installation guide or the lightweight installation guide for Modia3D.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"A standalone Modia3D version is installed with","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> ]add ModiaLang, Modia3D","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Modia3D animation can be exported in threejs-json-format and then imported in the open source web app threejs.org and use all the features of threejs, for example to export in the widely used glb format (= the binary version of the glTF format) and use any glb-viewer (for example 3D-Viewer of Windows 10).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Additionally, Modia3D uses the (free) community or the (commercial) professional version of the DLR Visualization Library for 3D simulations. It provides online animation (during simulation) and the generation of mpg4-videos. If you don't use the DLR Visualization Library result animation is switched of. Download and install the free DLR SimVis Community Edition, e.g. with https://visualization.ltx.de/ .","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Set an environment variable or add it to the startup.jl file. Please, read also the installation guide.\nENV[\"DLR_VISUALIZATION\"] = \"<path-to-library>/Visualization/Extras/SimVis\"\nMake sure that the SimVis executable under this directory has execution rights. For example in Linux with command: chmod ug+x <path-to-library>/Visualization/Extras/SimVis/linux/SimVis","category":"page"},{"location":"index.html#Publications","page":"Home","title":"Publications","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":" Paper or Talk Conference DOI or YouTube\n[1] Collision Handling with Variable-Step Integrators EOOLT 2017, December 10.1145/3158191.3158193\n[2] Component-Based 3D Modeling of Dynamic Systems American Modelica Conference 2018, October 10.3384/ECP18154175\n[3] Algorithms for Component-Based 3D Modeling 13th International Modelica Conference 2019, March 10.3384/ecp19157383\n[4a] Modia3D: Modeling and Simulation of 3D-Systems in Julia JuliaCon 2019, July 10.21105/jcon.00043\n[4b] Modia3D: Modeling and Simulation of 3D-Systems in Julia JuliaCon 2019, July YouTube\n[5] Collision Handling with Elastic Response Calculation and Zero-Crossing Functions EOOLT 2019, November 10.1145/3365984.3365986\n[6] Modia – Modeling Multidomain Engineering Systems with Julia JuliaCon 2021, July YouTube\n[7a] Modia – Equation Based Modeling and Domain Specific Algorithms 14th International Modelica Conference 2021, September 10.3384/ecp2118173\n[7b] Modia – Equation Based Modeling and Domain Specific Algorithms 14th International Modelica Conference 2021, September YouTube comming soon","category":"page"},{"location":"index.html#Release-Notes","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Version-0.9.0","page":"Home","title":"Version 0.9.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Non-backwards compatible changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Operator buildModia3D(..) is removed. Instead, the new constructor Model3D(..) must be used at the top level of a Modia3D definition. It is now possible to define several, independent multibody systems  (currently, only one of them can have animation and animation export).\nIf init/start vectors are defined (e.g. initial state of a FreeMotion joint), they must be defined as SVector{3,Float64}(..). Otherwise, errors occur during compilation. ","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Other changes","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"All test models changed, due to the non-backwards compatible change.\nCode generation changed significantly, in order that the interface to Modia3D functions is type stable. As a result, simulation is more efficient and much less memory is allocated during simulation.\nEfficiency improvements for collisions (less memory is allocated during simulation + faster simulation).","category":"page"},{"location":"index.html#Version-0.8.2","page":"Home","title":"Version 0.8.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Fix Cone contact detection\nAdd rattleback test (Modia3D/test/Collisions/Rattleback.jl)","category":"page"},{"location":"index.html#Version-0.8.1","page":"Home","title":"Version 0.8.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"collisionSmoothingRadius: edges are smoothed with collisionSmoothingRadius\nits default value is 0.001, if it is set to 0.0 no smoothing takes place\nthe edges of Box, Cylinder, Cone, and Beam are smoothened with collisionSmoothingRadius\nFor using Herz' pressure contactSphereRadius is introduced for each shape\nit can be user set\notherwise, it is calculated from shape geometry","category":"page"},{"location":"index.html#Version-0.8.0","page":"Home","title":"Version 0.8.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Require ModiaLang 0.10.0 (e.g. require DifferentialEquations 7)\nSupport animation export for FloatType = Measurements.XXX (animation is performed for the nominal value).\nRemove PathPlanning struct und functions (and instead use the functionality from ModiaLang 0.9.1).\nReactivate test model test/old/Test_PathPlanning.jl\nRemove unused files: .codecov.yml, .travis.yml, appveyor.yml\nFix import/using of some tests.","category":"page"},{"location":"index.html#Version-0.7.0","page":"Home","title":"Version 0.7.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia3D is updated and restricted to Julia 1.7\ncyclic dependencies with Modia package are removed","category":"page"},{"location":"index.html#Version-0.6.0","page":"Home","title":"Version 0.6.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Modia3D supports @instantiatedModel(FloatType = Float64, ...) as default FloatType. Now, further FloatTypes, such as Float32, DoubleFloats.Double64, Measurements.Measurement{Float64}, MonteCarloMeasurements.StaticParticles{Float64} are supported. If FloatType is not Float64, the default integrator selected from DifferentialEquations.jl is utilized and no longer Sundials.CVODEBDF (because CVODEBDF is only supported for Float64). Since ModiaLang does not yet support integrators with analytic Jacobians, integrators with this feature cannot be used, e.g., this feature needs to be switched off with option autodiff=false, if necessary. Recommendation: use QBDF(autodiff=false) if FloatType is not Float64. Note, Tsit5 usually does not work well for collisions, due to the stiff behavior in the contact area. Current limitations:\nFloatType = Float32: usually fails when collisions occur\nFloatType = Measurements.xxx, or MonteCarloMeasurements.xxx fail if events occur (e.g. collision handling, switching between different sequences of rotation angles)\nFloatType = Measurements.xxx: Animation is performed for the nominal values (plots show nominal values and the area of the variances)\nFloatType = MonteCarloMeasurements.yyy: Animation is automatically switched off with a warning message (due to severe performance issues that will be fixed in the future)\nObject3D: use vectors instead of matrices for rotation\nScene\nmaximumContactDamping = 2000.0: The maximum damping used in the elastice response calculation (previously, this was set to the literal value of 1000 and could not be changed). This value is, for example, used if the normal contact velocity at contact start is small.\nShape FileMesh is reading mesh-files with MeshIO.jl and no longer with an own parser. As a result, more input formats are supported, in particular also STL and OBJ with non-triangles. Furthermore, duplicate vertices in FileMesh are removed after reading a file. This reduces the computational effort of collision support point calculation.\nCollision handling slightly improved, e.g., if colliding shapes get in contact with a small normal contact velocity at contact start, the colliding shapes are quickly fixed relative to each other (previously, a lot of events occured in this phase).\nUpdated documentation and some bugs fixed\nInternal\nChanged most structs to parameterized structs with type parameter F (short for FloatType)\nChanged some remaining vectors and matrices to SVector and SMatrix, respectively, to improve efficiency\nCleanup of Modia3D and of Modia (e.g. removed duplicate definition of ModiaInterface in Modia.jl)\nEvent handling slightly changed, in particular the large contact hysteresis in the order of 1e-8 was reduced to 1e-13, after ModiaLang was using the new option RightRootFind of DifferentialEquations.jl. As a result, unnecessary events (signaled via restart = NoRestart) should no longer occur\nElastic response calculation simplified and improved. In particular, if the normal contact velocity at contact start is below vsmall (default = 0.01 m/s), coefficient of restitution is set to zero and no longer to 0.001. As a result, colliding shapes are quickly fixed relative to each other\nBug fixed: In some rare situations, it was not correctly checked that a multibody system has exactly one Object3D without parent and with feature=Scene (and no other Object3D has feature=Scene)","category":"page"},{"location":"index.html#Version-0.5.2","page":"Home","title":"Version 0.5.2","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"version number and date updated","category":"page"},{"location":"index.html#Version-0.5.1","page":"Home","title":"Version 0.5.1","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Collision handling - MPR algorithm improved to enhance speed and robustness\ncollision pairing material\nat initialization: a warning is given if a collision pairing material is not defined\nimprove support points computation of\nFileMesh: use SVectors and better computation of support points\nCapsule: a Capsule is already smooth therefore collisionSmoothingRadius is removed\nMPR algorithm\nDouble64 from DoubleFloats.jl package is used for mpr algorithm to increase accuracy\namount of iteration steps is increased if more are needed for phase 2 and phase 3\nif it's not possible to quit with the predefined mprTolerance the iteration quits with the best possible tolerance instead\ncollisions between ellipsoids and other shapes are treated like collisions between spheres and other shapes\nstore information like centroid in Object3D\nremove some type instabilities\nFreeMotion joint\nenable adaptive rotation sequence\nadd test model\nEnable ForceElements\nadd infrastructure\nadd Bushing and SpringDamperPtP\nadd test models and documentation\nAnimation export (three.js JSON object scene)\nfix initial orientation\nenable visualization of bounding boxes (AABB)\nenable Beam support\nenable Capsule support\nenable inner cylinder radius support (pipe)\nenable CoordinateSystem support\nenable Grid support\nVisualization with DLR Visualization Library\nadd visual shape kind ModelicaShape\nremove some type instabilities\nimprove testing\nenable short and complete test runs\nadd planar motion test\nupdate documentation and installation guide\nclean up: remove unused code snippets","category":"page"},{"location":"index.html#Version-0.5.0","page":"Home","title":"Version 0.5.0","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Largely redesigned.\nIntegrated into Modia.\nNot backwards compatible to previous versions.","category":"page"},{"location":"index.html#Main-developers","page":"Home","title":"Main developers","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Andrea Neumayr, Martin Otter and Gerhard Hippmann,\nDLR - Institute of System Dynamics and Control","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"Components/Object3D.html#Object3D","page":"Object3D","title":"Object3D","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"An Object3D constructor is the core element of Modia3D. It defines a coordinate system moving in 3D together with associated features like Scene, Visual and Solid:","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"(Image: Object3D)","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"CurrentModule = Modia3D.Composition","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Object3D","category":"page"},{"location":"Components/Object3D.html#Modia3D.Composition.Object3D","page":"Object3D","title":"Modia3D.Composition.Object3D","text":"Object3D(;\n    parent      = nothing,\n    translation = Modia3D.ZeroVector3D(F),\n    rotation    = Modia3D.ZeroVector3D(F),\n    feature     = nothing)\n\nGenerate a new Object3D object, that is a coordinate system (= frame, object3D) with associated feature that is described relatively to its (optional) parent Object3D.\n\nArguments\n\nAll arguments have default values. Thus, not all arguments must be defined.\n\nparent: Parent Object3D. If parent is present, the Object3D is defined relatively to the parent. If parent is not present, the Object3D is either a reference object (such as the world-Object3D), or the object is connected later with a joint to another Object3D.\ntranslation: Vector from the origin of the parent to the origin of the Object3D, resolved in the parent coordinate system in [m].\nExample: translation = [0.0, 0.5, 0.0] is a relative translation of 0.5 m in y-direction of the parent. If nothing is defined, the default value (= no translation) is taken.\nrotation: Vector [angleX, angleY, angleZ] to rotate the parent coordinate system along the x-axis with angleX, the y-axis with angleY and the z-axis with angleZ to arrive at the Object3D coordinate system. Angles can be provided in radians or with unit u\"°\" (degree).\nExample: rotation = [0.0, pi/2, 0.0] or rotation = [0.0, 90u\"°\", 0.0] defines that a rotation around the y-axis of the parent coordinate system with 90 degrees arrives at the Object3D. If nothing is defined, the default value (= no rotation) is taken.\nfeature: Defines the (optional) property associated with the Object3D by a constructor call. Supported constructors:\nScene: A Scene feature marks the root (world, origin) Object3D. It has no parent Object3D and allows to define global properties, such as the gravity field.\nVisual: A Visual feature defines a shape used for visualization.\nSolid: A Solid feature defines the solid properties of an Object3D, like mass, inertia tensor, collision behavior.\nnothing: No feature is associated with the Object3D. This might be useful for helper Object3Ds, for example to mark a point on a shape and connecting it later via a revolute joint.\n\nExample\n\nmodel = Model(\n    world      = Object3D(feature = Scene()),\n    worldFrame = Object3D(parent  = :world,\n                          feature = Visual(shape=CoordinateSystem())),\n    support    = Object3D(parent  = :world, translation = [0.0, 0.5, 0.0],\n                          feature = Visual(shape = Sphere(diameter=0.1)))\n)\n\n\n\n\n\n","category":"type"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"A feature defines a property that is associated with an Object3D. Currently, the following features are supported:","category":"page"},{"location":"Components/Object3D.html#Scene","page":"Object3D","title":"Scene","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Scene","category":"page"},{"location":"Components/Object3D.html#Modia3D.Composition.Scene","page":"Object3D","title":"Modia3D.Composition.Scene","text":"Scene(; kwargs...)\n\nDefines global properties of the system, such as the gravity field. Exactly one Object3D must have a Scene feature defined. This Object3D is used as inertial system (world, root) and is not allowed to have a parent Object3D.\n\nKeyword arguments defaults\ngravityField UniformGravityField()\nuseOptimizedStructure true\nenableContactDetection true\nmprTolerance 1.0e-20\nelasticContactReductionFactor 1.0     (<= 1.0 required)\nmaximumContactDamping 2000.0\nenableVisualization true\nanimationFile nothing\nvisualizeFrames false\nvisualizeBoundingBox false\nvisualizeContactPoints false\nvisualizeSupportPoints false\nnominalLength 1.0\ndefaultFrameLength 0.2*nominalLength\nnVisualContSupPoints 5\ndefaultContactSphereDiameter 0.1\ncameraDistance 10.0*nominalLength\ncameraLongitude 30/180*pi\ncameraLatitude 15/180*pi\nlightDistance 10.0*nominalLength\nlightLongitude 60/180*pi\nlightLatitude 45/180*pi\n\nArguments\n\ngravityField::Modia3D.AbstractGravityField: Gravity field of the scene. Supported values:\nNoGravityField,\nUniformGravityField,\nPointGravityField\nuseOptimizedStructure::Bool: = true, if pre-processing the whole system. For example, computing the common mass, common center of mass and common inertia tensor of all rigidly connected Object3Ds that have mass properties.\nenableContactDetection::Bool: = true, if contact detection is enable, see Collision Handling.\nmprTolerance::1.0e-20: Local tolerance used for terminating the mpr algorithm. Changing this value might improve speed.\nelasticContactReductionFactor::Float64: (> 0.0)\nusedContactCompliance = contactCompliance * elasticContactReductionFactor\nmaximumContactDamping: Maximum damping factor for elastic contacts\nenableVisualization::Bool: = true, to enable online animation with DLR SimVis. If SimVis is not installed, this flag has no effect.\nanimationFile::String: only if a valid path and name of the animation file is set (it must be a .json file) a json file is exported\nvisualizeFrames::Bool: = true, to visualize the coordinate system of every Object3D that is not explicitly switched off.\nvisualizeBoundingBox::Bool: Flag enabled for visualizing Axis Aligned Bounding Box (AABB) for all solid shapes allowed to collide\nvisualizeContactPoints::Bool: Flag enabled for visualizing contact points, and enableVisualization = true\nvisualizeSupportPoints::Bool: Flag enabled for visualizing support points, and enableVisualization = true\nnominalLength::Float64: Nominal length in [m].\ndefaultFrameLength::Float64: Default frame length in [m] for visualizing little CoordinateSystem.\nnVisualContSupPoints::Int64: defines how many contact as well as support points are visualized (there is a warning if you'll need to increase it)\ndefaultContactSphereDiameter::Float64: diameter of Sphere in [m] used for contact and support point visualization\ncameraDistance::Float64: distance between world frame and camera position\ncameraLongitude::Float64: longitude angle of camera position (0 = -y/-z/-x direction)\ncameraLatitude::Float64: latitude angle of camera position (0 = horizontal)\nlightDistance::Float64: distance between world frame and light position\nlightLongitude::Float64: longitude angle of light position (0 = -y/-z/-x direction)\nlightLatitude::Float64: latitude angle of light position (0 = horizontal)\n\n\n\n\n\n","category":"type"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"CurrentModule = Modia3D.Shapes","category":"page"},{"location":"Components/Object3D.html#Solid","page":"Object3D","title":"Solid","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Solid","category":"page"},{"location":"Components/Object3D.html#Modia3D.Shapes.Solid","page":"Object3D","title":"Modia3D.Shapes.Solid","text":"Solid(; shape = nothing,\n        solidMaterial = nothing,\n        massProperties = nothing,\n        collision = false,\n        contactMaterial = \"\",\n        collisionSmoothingRadius = 0.001,\n        contactSphereRadius = nothing,\n        visualMaterial = VisualMaterial())\n\nGenerate a Solid with physical behavior of a rigid body with mass, visualization and collision properties. Solid is used as feature of an Object3D.\n\nArguments\n\nshape: Defines the shape of the solid. Only Shapes from –– For Solid and Visual –– can be used.   If undefined the solid is not considered in visualization or Collision Handling and massProperties must   be explicitly defined.\nsolidMaterial: Defines the material of the solid used for mass properties computation and (if contactMaterial is   undefined) contact force calculation. A pre-defined Solid material from palettes/solidMaterials.json (e.g.   \"Steel\") or a user-defined Solid material (e.g. SolidMaterial(density=7850)) can be used.\nmassProperties: Defines the mass properties of the solid. If massProperties is undefined, the mass properties are   computed from shape and solidMaterial. It is also possible to define only the mass of the solid and compute the   center of mass and inertia tensor from shape (e.g. MassPropertiesFromShapeAndMass(mass=4.5)) or explicitly   define all mass properties (e.g. MassProperties(mass=4.5, centerOfMass=[1.0,2.0,3.0], Ixx=4.0, Iyy=5.0, Izz=6.0,   Ixy=4.5, Ixz=4.6, Iyz=5.5)).\ncollision: Defines if the solid is considered in Collision Handling. collision=true requires definition   of shape, mass properties (defined by solidMaterial or massProperties) and contact material (defined by   solidMaterial or contactMaterial).\ncontactMaterial: Defines the contact material for force computation with Contact Force Law (e.g. \"Steel\").   If undefined solidMaterial is used as contact material. Only contact material combinations defined in   palettes/contactPairMaterials.json can be used.\ncollisionSmoothingRadius: Defines a collision smoothing radius for surface edges, its default value is 0.001. It takes the minimum value of your collision smoothing radius and 10% of the smallest shape length, like min(collisionSmoothingRadius, 0.1 min(shape dimensions)). If it is set to 0.0 no collisionSmoothingRadius is used. A collisionSmoothingRadius is used for Box, Cylinder, Cone, and Beam.\ncontactSphereRadius: for each shape a contactSphereRadius is defined. So that Herz' pressure is used in Response calculation not only for spheres. You can define your own contactSphereRadius, otherwise it is computed from shape geometry (sketched in the following table).\n\nShape contactSphereRadius from shape\nSphere diameter/2\nEllipsoid min(lengthX, lengthY, lengthZ)/2\nBox min(lengthX, lengthY, lengthZ)/2\nCylinder min(diameter, length)/2\nCone (diameter + topDiameter)/4\nCapsule diameter/2\nBeam min(length, width, thickness)/2\nFileMesh shortestEdge/2\n\nFor flat shapes, Box and Beam, no contactSphereRadius is taken.  For Herz' pressure it is needed only if two flat shapes are colliding.\n\nvisualMaterial: Defines the material of the solid used for visualization. A pre-defined Visual material   from palettes/visualMaterials.json (e.g. \"RedTransparent\") or a user-defined Visual material (e.g.   VisualMaterial(color=\"DeepSkyBlue4\", transparency=0.75)) can be used.\n\nExample\n\nimport Modia3D\n\nSolid(; shape = Sphere(diameter=0.5),\n        solidMaterial = \"DryWood\",\n        collision = true,\n        contactMaterial = \"Steel\",\n        collisionSmoothingRadius = 0.001,\n        visualMaterial = VisualMaterial(color=\"DarkViolet\"))\n\n\n\n\n\n","category":"type"},{"location":"Components/Object3D.html#Examples-for-Solids","page":"Object3D","title":"Examples for Solids","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"How to compute or define mass properties?","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"# [M1]: mass properties are computed via shape geometry and predefined solidMaterial\r\n# with defined density, this is the default setting\r\nSolid(shape = Sphere(diameter=0.5), solidMaterial = \"Steel\")\r\n\r\n# [M2]: mass properties are computed via shape geometry and a defined mass\r\nSolid(shape = Sphere(diameter=0.5), massProperties = MassPropertiesFromShapeAndMass(mass=4.5))\r\n\r\n# [M3]: mass properties are explicitly defined: with mass, center of mass, inertia matrix.\r\n# For this option a shape and solidMaterial are optional.\r\nSolid(massProperties = MassProperties(mass=2.0, centerOfMass=[1,2,3],\r\n      Ixx=3.0, Iyy=4.0, Izz=4.0, Ixy=6.0, Ixz=7.0, Iyz=9.0) )","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"How to define Solids for Collision Handling? You always have to enable collision flag, and define a shape geometry. Make sure mass properties are computed and define how it behaves in contact situations.","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"# mass properties are computed like in [M1]\r\n# it behaves like \"Steel\" in contact situations\r\nSolid(shape = Sphere(diameter=0.5), solidMaterial = \"Steel\", collision = true)\r\n\r\n# mass properties are computed like in [M1]\r\n# it behaves like \"DryWood\" in contact situations\r\nSolid(shape = Sphere(diameter=0.5), solidMaterial = \"Steel\", collision = true,\r\n      contactMaterial = \"DryWood\")\r\n\r\n# mass properties are computed like in [M2]\r\n# it behaves like \"Steel\" in contact situations\r\nSolid(shape = Sphere(diameter=0.5),\r\n      massProperties = MassPropertiesFromShapeAndMass(mass=4.5),\r\n      solidMaterial = \"Steel\", collision = true)\r\n\r\n# mass properties are explicitly given like in [M3]\r\n# it behaves like \"Steel\" in contact situations\r\nSolid(shape = Sphere(diameter=0.5),\r\n      massProperties = MassProperties(mass=2.0, centerOfMass=[1,2,3],\r\n      Ixx=3.0, Iyy=4.0, Izz=4.0, Ixy=6.0, Ixz=7.0, Iyz=9.0),\r\n      solidMaterial = \"Steel\", collision = true)","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"The following functions are provided for a Solid shape that is associated with an Object3D","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Function Description\nvolume(shape) volume computation\ninertiaMatrix(shape, mass) returns inertia matrix of solid with respect to reference Object3D\ncentroid(shape) center of mass\nhasMass(object3D) check if a shape has mass properties\ncanCollide(object3D) checks if collision flag is enabled\nboundingBox(shape, <other arguments>) bounding box - broad phase of Collision Handling\nsupportPoint(shape, <other arguments>) needed for narrow phase of Collision Handling\nfurther functions ...","category":"page"},{"location":"Components/Object3D.html#Visual","page":"Object3D","title":"Visual","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Visual","category":"page"},{"location":"Components/Object3D.html#Modia3D.Shapes.Visual","page":"Object3D","title":"Modia3D.Shapes.Visual","text":"Visual(;\n    shape = Sphere(diameter = 0.5),\n    visualMaterial = VisualMaterial(color = \"Green\"))\n\nGenerate a new visual shape with a visual material. It is only for visualizing, without physical behavior. In this case it is a greenish sphere.\n\nArguments\n\nshape: it is possible to use all Shapes from both sets visual and solid, e.g. Sphere, Box, CoordinateSystem. The default value is nothing, this means it will not be visualized.\nvisualMaterial: use a predefined Visual material defined in palettes/visualMaterials.json, or define it with VisualMaterial(color = \"Blue\"). The default value is VisualMaterial().\n\n\n\n\n\n","category":"type"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"An Object3D is visible in visualization and animation export if a shape and a visualMaterial are defined.","category":"page"},{"location":"Components/Object3D.html#Examples-for-displaying-Solid-and-Visual-features","page":"Object3D","title":"Examples for displaying Solid and Visual features","text":"","category":"section"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Visual features","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"# a visual shape is displayed with a user defined visual material\r\nVisual(shape = Sphere(diameter=0.5), visualMaterial = VisualMaterial(color = \"goldenrod1\"))\r\n\r\n# a visual shape is displayed with a default visual material\r\nVisual(shape = Sphere(diameter=0.5))","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"Solid features","category":"page"},{"location":"Components/Object3D.html","page":"Object3D","title":"Object3D","text":"# a solid shape is displayed with a user defined visual material\r\nSolid(shape = Sphere(diameter=0.5), visualMaterial = VisualMaterial(color = \"aquamarine4\"))\r\n\r\n# a solid shape is displayed with a user defined visual material\r\nSolid(shape = Sphere(diameter=0.5))\r\n\r\n# this solid shape is NOT displayed\r\nSolid(shape = Sphere(diameter=0.5), visualMaterial = nothing)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"﻿","category":"page"},{"location":"internal/ContactForceLaw.html#Contact-Force-Law","page":"Contact Force Law","title":"Contact Force Law","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Modia3D supports Collision Handling of objects that are defined with a contact material and (a) have a convex geometry, or (b) can be approximated by a set of convex geometries, or (c) have a concave geometry that is (automatically) approximated by its convex hull. When contact occurs, the response is computed with elastic (nonlinear) force/torque laws based on the penetration depth and the relative motion of the objects in contact. It is planned to optionally also support impulsive response calculation in the future.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"This section is based on [4] with some minor improvements as used in the current version of Modia3D.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The current approach has several limitations that a user must know, in order that a simulation is successful:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The current collision handling is designed for variable step-size integrators for systems that have realistic physical material behavior.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Usually, a relative tolerance of 10^-8 or smaller has to be used since otherwise a variable step-size integrator will typically fail. The reason is that the penetration depth is computed from the difference of tolerance-controlled variables and the precision will be not sufficient if a higher tolerance will be used because the penetration depth of hard contact materials is in the order of 10^-5  10^-6 m. A relative tolerancie of 10^-5 might be used, if the heuristic elastic contact reduction factor  is set to k_red = 10^-4 (see Material constants below).","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"A reasonable reliable simulation requires that objects have only point contact, since otherwise the contact point can easily jump between model evaluations and a variable step-size integrator will not be able to cope with this, so will terminate with an error. For this reason, all geometrical objects are slightly modified in various ways for the collision handling. Most important, all geometries are smoothed with a small sphere (e.g. with radius = 1mm) that is moved over all surfaces. Basically, this also means that if two objects are in contact, one of them should be a Sphere or an Ellipsoid.","category":"page"},{"location":"internal/ContactForceLaw.html#Material-constants","page":"Contact Force Law","title":"Material constants","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The response calculation uses the following material constants from the Solid material palette and from the Contact pair material palette.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"YoungsModulus or E in [N/m^2]: Young's modulus of contact material (gt 0).\nPoissonsRatio or nu: Poisson's ratio of contact material (0 lt nu lt 1).\ncoefficientOfRestitution or cor: Coefficient of restitution between two objects (0 le cor le 1).\nslidingFrictionCoefficient or mu_k: Kinetic/sliding friction force coefficient between two objects (ge 0).\nrotationalResistanceCoefficient or mu_r: Rotational rolling resistance torque coefficient between two objects (ge 0).","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Additionally, the response calculation is changed at small relative velocities and relative angular velocities. This region is defined by the following constants:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"vsmall in [m/s]: Used for regularization when computing the unit vector in direction of                    the relative tangential velocity (see below).\nwsmall in [rad/s]: Used for regularization when computing the unit vector in direction of                      the relative angular velocity (see below).","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Finally, the heuristic factor k_red (default = 1.0) can be defined with keyword argument elasticContactReductionFactor in the Scene constructor. The goal is the following: Applying the elastic response calculation on hard materials such as steel, typically results in penetration depths in the order of 10^-5  10^-6 m. A penetration depth is implicitly computed by the difference of the absolute positions of the objects in contact and these absolute positions are typically error-controlled variables of the integrator. This in turn means that typically at least a relative tolerance of 10^-8 needs to be used for the integration, in order that the penetration depth is computed with 2 or 3 significant digits. To improve simulation speed, factor k_red reduces the stiffness of the contact and therefore enlarges the penetration depth. If k_red is for example set to 10^-4, the penetration depth might be in the order of 10^-3 m and then a relative tolerance of 10^-5 might be sufficient. In many cases, the essential response characteristic is not changed (just the penetration depth is larger), but simulation speed is significantly improved.","category":"page"},{"location":"internal/ContactForceLaw.html#Response-calculation","page":"Contact Force Law","title":"Response calculation","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Assume two shapes penetrate each other as shown in the following figure:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"(Image: contact)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The intuition is that there is a contact area with a certain pressure distribution in normal and a stress distribution in tangential direction and that the response characteristics provides an approximation of the resultant contact normal force vecf_n, resultant tangential force vecf_t, and resultant contact torque vectau The MPR algorithm calculates an approximation of the contact point, of the signed distance delta and of a unit vector vece_n that is orthogonal to the contacting surfaces. When penetration occurs, delta ge 0, and the contact response is computed from the elastic contact materials of the two objects in the following way, for more details see [4] (the contact force law in normal direction is based on [1], [3], the remaining force law on [2] with some extensions and corrections):","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"beginalign\r\nf_n        = k_red maxleft(0 c_res cdot c_geo cdot delta^n_geo cdot (1 + d cdot dotdelta) right) \r\nvecf_n = f_n cdot vece_n \r\nvecf_t = -mu_k cdot f_n cdot vece_treg \r\nvectau = -mu_r cdot mu_rgeo  cdot f_n cdot vece_omegareg\r\nendalign","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"where","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"vece_n: Unit vector perpendicular to the surface of object 1 at the contact point, pointing outwards.\nvece_treg: Regularized unit vector in direction of the tangential relative velocity (see below).\nvece_omegareg: Regularized unit vector in direction of the relative angular velocity (see below).\nf_n: Value of normal contact force in direction of vece_n acting on object 2 (f_n ge 0).\nvecf_n: Vector of normal contact force acting on object 2.\nvecf_t: Vector of sliding friction force acting on object 2 in opposite direction of the movement                 in the tangential plane of the contact.\nvectau: Vector of rolling resistance torque acting on object 2, in opposite direction to the                   relative angular velocity between the two contacting objects.\ndelta: Signed distance between object 1 and 2 in normal direction vece_n.              delta  0 if objects are penetrating each other.\ndotdelta: Signed relative velocity between object 1 and 2 in normal direction vece_n.\nc_res: Resultant elastic material constant in normal direction. This constant is computed        from the constants c_1 c_2 of the two contacting objects 1 and 2 as        c_res = 1left( 1c_1 + 1c_2 right). c_i is computed from the material properties as        c_i = E_i(1 - nu_i^2) where E_i is Young's modules and        nu_i is Poisson's ratio of object i.\nc_geo: Factor in f_n that is determined from the geometries of the              two objects (see below).\nn_geo: Exponent in f_n that is determined from the geometries of the              two objects (see below).\nd(cor_curdotdelta^-): Damping coefficient in normal direction as a function of        cor_cur and dotdelta^- (see below).\ncor_cur: Current coefficient of restitution between objects 1 and 2, see below.\ndotdelta^-: Value of dotdelta when contact starts (dotdelta^- ge 0).\nmu_k: Kinetic/sliding friction force coefficient between objects 1 and 2.\nmu_r: Rotational rolling resistance torque coefficient between objects 1 and 2.\nmu_rgeo: Factor in vectau that is determined from the geometries of the                   two objects (see below).\nk_red: Elastic contact reduction factor.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The max() operator in equation (1) is conceptually provided, in order to guarantee that f_n is always a compressive and never a pulling force because this would be unphysical. In the actual implementation no max() function is used, because an event is triggered when delta drops below zero (so no penetration anymore) and after the event no force/torque is applied anymore (meaning that f_n is only evaluated for about delta  - 10^-19  - 10^-24 m (this depends on the contact situation and the contact materials)).","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"In special cases (for example sphere rolling on a plane), the rotational coefficient of friction mu_rres can be interpreted as rolling resistance coefficient.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Coefficients c_geo n_geo mu_rgeo depend on the geometries of the objects that are in contact. Only for spheres meaning values are provided based on Hertz' pressure, because currently the collision handling in Modia3D does no provide enough information for other geometries (r_i is the radius of sphere i):","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Object 1 Object 2 c_geo n_geo mu_rgeo\nSphere Sphere frac43 sqrt1(1r_1+1r_2) 15 1(1r_1+1r_2)\nSphere no Sphere frac43 sqrtr_1 15 r_1\nno Sphere no Sphere 1 10 10","category":"page"},{"location":"internal/ContactForceLaw.html#Regularized-unit-vectors","page":"Contact Force Law","title":"Regularized unit vectors","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The unit vectors vece_t vece_omega are undefined if the relative velocity and/or the relative angular velocity vanish. They are therefore approximately calculated using utility function reg(v_abs v_small). This function returns v_abs if v_abs ge v_small and otherwise returns a third order polynomial with a minimum of v_small3 at v_abs=0 and smooth first and second derivatives at v_abs = v_small):","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"reg(v_abs v_small) = textif v_abs ge v_small textthen v_abs textelse\r\n                          fracv_abs^2v_small\r\n                          left( 1 - fracv_abs3v_small right) + fracv_small3","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Example for v_small = 01:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"(Image: Regularization function)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"With vecv_i the absolute velocity of the contact point of object i, and vecomega_i the absolute angular velocity of object i, the regularized unit vectors are calculated with function reg() in the following way:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"beginalign\r\nvece_treg       = fracvecv_reltreg(vecv_relt v_small) quad\r\n                          vecv_rel = vecv_2 - vecv_1 \r\n                          vecv_relt = vecv_rel  - (vecv_rel cdot vece_n) vece_n \r\nvece_omegareg = fracvecomega_relreg(vecomega_relomega_small) quad\r\n                          vecomega_rel = vecomega_2 - vecomega_1\r\nendalign","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The effect is that the absolute value of a regularized unit vector is approximated by the following smooth characteristics (and therefore the corresponding friction force and contact torque have a similar characteristic)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"(Image: Sliding friction force)","category":"page"},{"location":"internal/ContactForceLaw.html#Damping-coefficient","page":"Contact Force Law","title":"Damping coefficient","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"There are several proposal to compute the damping coefficient as a function of the coefficient of restitution cor and the velocity when contact starts dotdelta^-. For a comparision of the different formulations see [1], [3].","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Whenever the coefficient of restitution cor  0, then an object 2 jumping on an object 1 will mathematically never come to rest, although this is unphysical. To fix this, the value of a coefficient of restitution is set to zero at contact start when the normal velocity at this time instant is smaller as v_small:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"cor_cur = textif dotdelta^-  v_small textthen cor textelse 0","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"The damping coefficient d is basically computed with the formulation from [1] because a response calculation with impulses gives similar results for some experiments as shown in [3]. However, (a) instead of cor, the current coefficient of restitution cor_cur is used and (b) the damping coefficient is limited to d_max (this parameter is set via maximumContactDamping in object Scene and has a default value of 1000 Nsm) to avoid an unphysical strong creeping effect for collisions with small cor_cur values:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"d(cor_curdotdelta^-) = min(d_max frac8(1-cor_cur)5 cdot cor_cur cdot dotdelta^-)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Note, if cor_cur = 0, then d = min(d_max 80) = d_max.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"Examples of this characteristics are shown in the next figure:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"(Image: Damping coefficient)","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"In the next figure the simulation of a bouncing ball is shown where the response calculation is performed (a) with an impulse and (b) with the compliant force law above. In both cases the coefficient of restitution cor is zero when dotdelta^-  001. As can be seen, both formulations lead to similar responses:","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"(Image: Bouncing ball)","category":"page"},{"location":"internal/ContactForceLaw.html#Literature","page":"Contact Force Law","title":"Literature","text":"","category":"section"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"[1]: Paulo Flores, Margarida Machado, Miguel Silva, Jorge Martins (2011):   On the continuous contact force models for soft materials in   multibody dynamics.   Multibody System Dynamics, Springer Verlag,   Vol. 25, pp. 357-375. 10.1007/s11044-010-9237-4.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"[2]: Martin Otter, Hilding Elmqvist, José Díaz López (2005):   Collision Handling for the Modelica MultiBody Library.   Proceedings of the 4th International Modelica Conference 2005,   Gerhard Schmitz (Ed.), pages 45-53.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"[3]: Luka Skrinjar, Janko Slavic, Miha Boltezar (2018):   A review of continuous contact-force models in multibody dynamics.   International Journal of Mechanical Sciences, Volume 145,   Sept., pages 171-187.","category":"page"},{"location":"internal/ContactForceLaw.html","page":"Contact Force Law","title":"Contact Force Law","text":"[4]: Andrea Neumayr, Martin Otter (2019):   Collision Handling with Elastic Response Calculation and Zero-Crossing Functions.   Proceedings of the 9th International Workshop on Equation-Based Object-Oriented Modeling Languages and Tools. EOOLT’19. ACM, pp. 57–65.","category":"page"}]
}
